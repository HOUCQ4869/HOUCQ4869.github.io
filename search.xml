<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OSLab1</title>
      <link href="/2023/04/06/oslab1/"/>
      <url>/2023/04/06/oslab1/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab1-实验报告"><a href="#Lab1-实验报告" class="headerlink" title="Lab1 实验报告"></a>Lab1 实验报告</h1><p><strong>PB21111618 侯超群</strong></p><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>本次实验用于实现multiboot header部分,并在屏幕以及串口上输出特定内容；</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="multiboot启动协议介绍"><a href="#multiboot启动协议介绍" class="headerlink" title="multiboot启动协议介绍"></a>multiboot启动协议介绍</h3><p>multiboot作为一种启动引导协议，能够制定bootloader和操作系统之间的接口，解决多系统与不同bootloader可能的矛盾；</p><h3 id="qemu介绍"><a href="#qemu介绍" class="headerlink" title="qemu介绍"></a>qemu介绍</h3><p>qemu作为模拟器，用于模拟硬件设备，其支持multiboot协议，在该实验中，用于提供裸机环境，使用qemu启动所编写的内核；</p><h3 id="VGA介绍"><a href="#VGA介绍" class="headerlink" title="VGA介绍"></a>VGA介绍</h3><p>VGA作为一种显示方式，可以通过向VGA显存中写入内容来实现字符的显示；<br>VGA显存起始地址0xB8000,由存放字符的ASCLl码以及该字符的显示属性构成两个字节；<br><a href="https://imgse.com/i/ppI6xiR"><img src="https://s1.ax1x.com/2023/04/06/ppI6xiR.png" alt="VGA"></a></p><h3 id="串口介绍"><a href="#串口介绍" class="headerlink" title="串口介绍"></a>串口介绍</h3><p>UART，全称通用异步收发传输器，是一种串行异步收发协议，原理是将传输数据的每个二进制位一位一位地传输；<br>在qemu中，在没有初始化波特率的情况下，也可以直接写UART，正确输出；<br>串口端口地址为0x3F8，可依次调用，实现各个字符输出；</p><h2 id="源代码说明"><a href="#源代码说明" class="headerlink" title="源代码说明"></a>源代码说明</h2><pre class="line-numbers language-none"><code class="language-none">movl $0x2f652f48, 0xB8000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该段代码中，将字符以及显示属性，写入VGA显存中，其中0x2f652f48中,65,48分别对应ASCLL码中的e,H；前面的2f为其显示属性，写入到起始地址0x8000；</p><pre class="line-numbers language-none"><code class="language-none">movw $0x3F8, %dx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该段代码中，初始化串口，将串口端口地址存入dx寄存器，便于之后输出显示；</p><pre class="line-numbers language-none"><code class="language-none">movb $0x68, %al<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该段代码中，将待显示的字符h写入寄存器al中，再通过outb实现输出；</p><h2 id="代码布局说明"><a href="#代码布局说明" class="headerlink" title="代码布局说明"></a>代码布局说明</h2><pre class="line-numbers language-none"><code class="language-none">OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)OUTPUT_ARCH(i386)ENTRY(start)SECTIONS &#123;        . &#x3D; 1M;        .text : &#123;                *(.multiboot_header)                . &#x3D; ALIGN(8);                *(.text)        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>.表示当前位置，则.&#x3D;1M使用物理内存的1M开始放置数据和代码；</li><li>内容以multiboot_header开始，12个字节；</li><li>.&#x3D;ALIGN(8)，8字节对齐后放置写入VGA的代码；</li></ul><h2 id="编译过程说明"><a href="#编译过程说明" class="headerlink" title="编译过程说明"></a>编译过程说明</h2><pre class="line-numbers language-none"><code class="language-none">ASM_FLAGS&#x3D; -m32 --pipe -Wall -fasm -g -O1 -fno-stack-protectormultibootHeader.bin: multibootHeader.Sgcc -c $&#123;ASM_FLAGS&#125; multibootHeader.S -o multibootHeader.old -n -T multibootHeader.ld multibootHeader.o -o multibootHeader.binclean:rm -rf .&#x2F;multibootHeader.bin .&#x2F;multibootHeader.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>以上为Makefile文件，ASM_FLAGS先定义汇编标记，表示编译中gcc指令的参数；</li><li>使用gcc生成目标文件.o文件；</li><li>根据链接器.ld文件，根据部署要求从.o文件得到.bin文件；</li><li>clean指令用于删除生成的.o文件和.bin文件；</li></ul><p>在使用make指令生成.bin文件后，输入如下指令来运行qemu</p><pre class="line-numbers language-none"><code class="language-none">qemu-system-i386 -kernel multibootHeader.bin -serial stdio<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中qemu-system-i386指定平台i386，-kernel指定内核文件，-serial stdio指定串行终端为标准输入输出</p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ul><li>串口输出如下：<strong>显示hcq</strong><br><img src="https://s1.ax1x.com/2023/04/06/ppI6jo9.png" alt="串口显示"></li><li>VGA输出如下：<strong>显示Hello,PB21111618-houchaoqun!</strong><br><img src="https://s1.ax1x.com/2023/04/06/ppI6XdJ.png" alt="VGA显示"></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>开始时使用vmware虚拟机时在Vmaretools设置共享文件夹，但无法找到&#x2F;mnt&#x2F;c&#x2F;下的共享文件夹，经搜索无果，因此又采用了第一种方法配置wsl2，通过建立符号链接实现配置；</p>]]></content>
      
      
      <categories>
          
          <category> OSLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph</title>
      <link href="/2023/02/22/graph/"/>
      <url>/2023/02/22/graph/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><h2 id="定义-amp-概念"><a href="#定义-amp-概念" class="headerlink" title="定义&amp;概念"></a>定义&amp;概念</h2><p>相关概念：</p><ul><li><strong>有向图</strong>， <strong>无向图</strong>，<strong>简单图</strong>， <strong>完全图</strong>，<strong>有向完全图</strong>（弧数为前者两倍），稀疏图、稠密图；  </li><li>顶点不重复-&gt;<strong>简单</strong>路径&#x2F;回路&#x2F;环；  </li><li>（无向图中）<strong>连通图</strong>：任意两个顶点都是连通的；<strong>连通分量</strong>：无向图中的极大连通子图；</li><li>（有向图中）<strong>强连通图</strong>：a-&gt;b,b-&gt;a均存在路径；<strong>强连通分量</strong>：有向图中的极大连通子图；</li><li><strong>生成树</strong>：一个极小连通子图；在非连通图中，连通分量的生成树构成了非连通图的<strong>生成森林</strong>；</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="数组表示法（邻接矩阵）"><a href="#数组表示法（邻接矩阵）" class="headerlink" title="数组表示法（邻接矩阵）"></a>数组表示法（邻接矩阵）</h3><p>对于无向图的邻接矩阵，其一定是一个对称矩阵，而对于有向图而言并不对称；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define INFINITY INT_MAX  &#x2F;&#x2F; 最大值#define MAX_VERTEX_NUM 20 &#x2F;&#x2F; 最大顶点个数typedef int VRType;     &#x2F;&#x2F; 顶点关系类型，无权图1,0表相邻，带权图表权值typedef int *InfoType;  &#x2F;&#x2F; 弧相关信息指针typedef int VertexType; &#x2F;&#x2F; 顶点向量typedef enum&#123;  DG,  DN,  UDG,  UDN&#125; GraphKind; &#x2F;&#x2F;&#123;有向图，有向网，无向图，无向网&#125;typedef struct ArcCell&#123;  VRType adj;  InfoType *info;&#125; ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct&#123;  VertexType vexs[MAX_VERTEX_NUM];  AdjMatrix arcs;     &#x2F;&#x2F; 邻接矩阵  int vexnum, arcnum; &#x2F;&#x2F; 顶点数及弧数  GraphKind kind;     &#x2F;&#x2F; 图的种类标志&#125; MGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>邻接矩阵表示法的空间复杂度为O(n^2)，适合稠密图进行存储表示；</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>链式存储结构，在邻接表中，对图中每个顶点建立一个单链表，单链表中每个节点表示依附于该顶点的各边。<br>每个节点由三个域组成，邻接点域指示与该弧指向的顶点位置；链域指示下一条边或弧的节点；数据域存储边或弧的相关信息，如权值等；在每个链表上附设一个表头节点，包含指向第一条弧的链域以及顶点信息；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 邻接表#define MAX_VERTEX_NUM 20typedef struct ArcNode&#123; &#x2F;&#x2F; 弧节点  int adjvex;              &#x2F;&#x2F; 该弧指向的顶点位置  struct ArcNode *nextarc; &#x2F;&#x2F; 指向下一条弧的指针  InfoType *info;          &#x2F;&#x2F; 该弧相关信息的指针&#125; ArcNode;typedef struct VNode&#123;   VertexType data;   &#x2F;&#x2F; 顶点信息  ArcNode *firstarc; &#x2F;&#x2F; 指向第一条依附于该顶点的弧的指针&#125; VNode, AdjList[MAX_VERTEX_NUM];typedef struct&#123;  AdjList vertices;  int vexnum, arcnum; &#x2F;&#x2F; 图的当前顶点数和弧数  int kind;           &#x2F;&#x2F; 图的种类标志&#125; ALGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>邻接表的表示方式便于实现对于出度的求解，然而对于入度，则必须遍历整个邻接表。为此可以建立一个有向图的逆邻接表，加速求解给定顶点的入度；</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>十字链表可视作将有向图的邻接表与逆邻接表结合起来，<br>弧节点中有五个域，尾域tailvex和头域headvex分别指示弧尾和弧头这两个顶点在图中的位置；链域hlink指向弧头相同的下一条弧；链域tlink指向弧尾相同的下一条弧；info域指示相关信息；<br>顶点节点有三个域，data域存储节点相关信息；firstin及firstout两个链域分别指向以该顶点为弧头或弧尾的第一个弧节点；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 十字链表#define MAX_VERTEX_NUM 20typedef struct ArcBox&#123;  int tailvex, headvex;         &#x2F;&#x2F; 该弧的尾和头顶点的位置  struct ArcBox *hlink, *tlink; &#x2F;&#x2F; 分别为弧头相同和弧尾相同的弧的链域  InfoType *info;               &#x2F;&#x2F; 该弧相关信息&#125; ArcBox;typedef struct VexNode&#123;  VertexType data;  ArcBox *firstin, *firstout; &#x2F;&#x2F; 分别指向该顶点的第一条入弧和出弧&#125; VexNode;typedef struct&#123;  VexNode xlist[MAX_VERTEX_NUM]; &#x2F;&#x2F; 表头向量  int vexnum, arcnum;            &#x2F;&#x2F; 有向图的当前顶点数和弧数&#125; OLGraph;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>未完待续……</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h3><p>类似于树的先根遍历，假设初始状态是图中所有顶点未曾被访问，DFS从某一顶点v出发，访问该节点，依次从v的未被访问的邻接点出发深度优先遍历图，指示图中所有和v有路径相通的顶点都被访问到；若此时还有顶点未被访问，则另选一个未被访问的顶点做起点，继续DFS;</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef int Status;int visited[MAX_VERTEX_NUM]; &#x2F;&#x2F; 访问标记数组Status (*VisitFunc)(int v);  &#x2F;&#x2F; 函数变量&#x2F;&#x2F;该处不一定是MGraphvoid DFSTraverse(MGraph G, Status (*Visit)(int v))&#123;                    &#x2F;&#x2F; 对图G作深度优先遍历  VisitFunc &#x3D; Visit; &#x2F;&#x2F; 使用全局变量VisitFunc, 使DFS不必设函数指针参数  for (int v &#x3D; 0; v &lt; G.vexnum; v++)    visited[v] &#x3D; 0; &#x2F;&#x2F; 初始化  for (int v &#x3D; 0; v &lt; G.vexnum; v++)    if (!visited[v]) &#x2F;&#x2F; 对未访问节点调用DFS      DFS(G, v);&#125;void DFS(MGraph G, int v)&#123; &#x2F;&#x2F; 从第v个顶点出发递归地深度优先遍历图G  visited[v] &#x3D; 1;  VisitFunc(v);  for (int w &#x3D; FirstAdjVex(G, v); w &gt;&#x3D; 0; w &#x3D; NextAdjVex(G, v, w))    if (!visited[w])      DFS(G, w); &#x2F;&#x2F; 对尚未访问的邻接顶点w递归调用DFS&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>类似于树的按层次遍历，假设从图中某顶点v出发，访问v后依次访问v的各个未曾访问的邻接点，然后从这些邻接点出发依次访问他们的邻接点，而且要求“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至所有已访问顶点的邻接点均被访问。同样，若存在未被访问的节点，选取并重复上述过程；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void BFSTraverse(MGraph G, Status (*Visit)(int v))&#123; &#x2F;&#x2F; 按广度优先非递归遍历图G，使用辅助队列Q和访问标志数组visited  for (int v &#x3D; 0; v &lt; G.vexnum; v++)    visited[v] &#x3D; 0; &#x2F;&#x2F; 初始化  SqQueue *Q &#x3D; (SqQueue *)malloc(sizeof(SqQueue));  InitQueue(Q); &#x2F;&#x2F;  for (int v &#x3D; 0; v &lt; G.vexnum; v++)  &#123;    if (!visited[v])    &#123;      visited[v] &#x3D; 1;      Visit(v);      EnQueue(Q, v); &#x2F;&#x2F; 入队，便于之后先层次遍历      while (!QueueEmpty(Q))      &#123; &#x2F;&#x2F; 若队列不空        int *u &#x3D; (int *)malloc(sizeof(int));        DeQueue(Q, u); &#x2F;&#x2F; 出队，进行层次遍历        for (int w &#x3D; FirstAdjVex(G, u); w &gt;&#x3D; 0; w &#x3D; NextAdjVex(G, u, w))          if (!visited[w])          &#123;            visited[w] &#x3D; 1;            Visit(w);            EnQueue(Q, w); &#x2F;&#x2F; 将初次访问节点再次入队          &#125;      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h2><h3 id="无向图的连通分量和生成树"><a href="#无向图的连通分量和生成树" class="headerlink" title="无向图的连通分量和生成树"></a>无向图的连通分量和生成树</h3><p>由DFS搜索得到的为<strong>深度优先生成树（森林）</strong>，由BFS搜索得到的为<strong>广度优先生成树（森林）</strong><br>假设以孩子兄弟链表作为生成森林的存储结构，如下算法生成非连通图的深度优先生成森林：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h3><p>未完待续……</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>构造连通网的最小代价生成树（简称为最小生成树）问题；<br>多数算法借助最小生成树的一种简称为MST的性质：假设连通网N&#x3D;(V,{E})，U是顶点集V的一个非空子集，若(u,v)是一条具有最小权值的边，其中顶点u属于U，顶点v属于V-U，则必存在一颗包含边(u,v)的最小生成树；<br>如下介绍普里姆算法(Prim)和克鲁斯卡尔算法(Kruskal):</p><ul><li><strong>Prim</strong></li></ul><p>从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复找最短的边并添加；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 记录从顶点集U-&gt;U-V的代价最小的边的辅助数组定义:struct&#123;  VertexType adjvex;  VRType lowcost;&#125; closedge[MAX_VERTEX_NUM];void MiniSpanTree_PRIM(MGraph G, VertexType u)&#123; &#x2F;&#x2F; 用普里姆算法从第u个顶点出发构造网G的最小生成树T，输出T的各条边  int k &#x3D; LocateVex(G, u);  for (int j &#x3D; 0; j &lt; G.vexnum; j++)  &#123; &#x2F;&#x2F; 辅助数组初始化，此时顶点集中元素只有u    if (j !&#x3D; k)    &#123;      closedge[j].adjvex &#x3D; u;      closedge[j].lowcost &#x3D; G.arcs[k][j].adj;    &#125;  &#125;  closedge[k].lowcost &#x3D; 0; &#x2F;&#x2F; 初始顶点，U&#x3D;&#123;u&#125;  for (int i &#x3D; 1; i &lt; G.vexnum; i++)  &#123;    k &#x3D; minimum(closedge);    &#x2F;&#x2F;minimum函数实现在U-V顶点集中找到距U顶点集最近的顶点    &#x2F;&#x2F;即closedge中在U-V顶点集中lowcost最小的顶点    printf(closedge[k].adjvex, G.vexs[k]);    &#x2F;&#x2F;输出生成树的边    closedge[k].lowcost &#x3D; 0;    &#x2F;&#x2F;将该点加入U顶点集中，即此时代价为0    for (int j &#x3D; 0; j &lt; G.vexnum; j++)    &#123; &#x2F;&#x2F;由于k并入U中，重新规划辅助数组，判断代价是否有更小的变化      if (G.arcs[k][j].adj &lt; closedge[j].lowcost)      &#123;        closedge[j].adjvex &#x3D; G.vexs[k];        closedge[j].lowcost &#x3D; G.arcs[k][j].adj;      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Kruskal</strong></li></ul><p>假设初始状态为n个顶点而无边的存在，在该图中每个顶点自成一个连通分量；在E中选择代价最小的边，若该边依附的顶点在T的不同连通分量上，则可以将该边加入T中，否则另取下一条代价最小的边；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">未完待续……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="有向无环图及其应用"><a href="#有向无环图及其应用" class="headerlink" title="有向无环图及其应用"></a>有向无环图及其应用</h2><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为<strong>AOV网</strong>；一个无环的有向图称作**有向无环图(DAG)**；</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为<strong>拓扑排序</strong>；</p><p>如何进行拓扑排序：</p><ul><li>从有向图中选一个没有前驱的顶点并输出；</li><li>从图中删除该顶点和所有以它为尾的弧；</li><li>重复以上过程，直至全部顶点均输出，或者当前图中不存在无前驱的顶点为止；</li></ul><p>采取邻接表作为有向图的存储结构，且在头结点中增加一个存放顶点入度的数组indegree;同时为避免重复检测入度为零的顶点，另设一栈暂存所有入度为零的顶点；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status TopologicalSort(ALGraph G)&#123;  int indegree[MAX_VERTEX_NUM];  FindInDegree(G, indegree); &#x2F;&#x2F; 对各顶点求入度  SqStack *S &#x3D; (SqStack *)malloc(sizeof(SqStack));  InitStack(S); &#x2F;&#x2F; 建零入度顶点栈  for (int i &#x3D; 0; i &lt; G.vexnum; i++)  &#123; &#x2F;&#x2F; 入度为零者进栈    if (!indegree[i])      Push(S, i);  &#125;  int count &#x3D; 0;  while (!StackEmpty(S))  &#123;    int *i &#x3D; (int *)malloc(sizeof(int));    Pop(S, i);    printf(i, G.vertices[*i].data);    count++; &#x2F;&#x2F; 输出i号顶点并计数    for (ArcNode *p &#x3D; G.vertices[*i].firstarc; p; p &#x3D; p-&gt;nextarc)    &#123;      int k &#x3D; p-&gt;adjvex;      if (!(--indegree[k]))        Push(S, k); &#x2F;&#x2F; 对于删除节点后入度减为零的节点进行入栈操作    &#125;  &#125;  if (count &lt; G.vexnum)    return ERROR; &#x2F;&#x2F; 此时有向图有回路  else    return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于输出每个顶点的同时还要删除以它为起点的边，因此拓扑排序的时间复杂度为O(n+e);<br>考虑有向图中无环时，也可以利用深度优先遍历实现拓扑排序，由于从某点出发进行深度优先搜索遍历时，最先退出DFS函数的顶点即出度为零的顶点，也即是拓扑有序序列中最后一个顶点，因此按照退出DFS函数的先后记录下来的顶点序列即为逆向的拓扑有序序列；</p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之用边表示活动的网络，简称<strong>AOE网</strong>；</p><p>再次表明AOE网与AOV网的异同，两者都是有向无环图，不同之处在于边和顶点表示的含义是不同的，AOE网中的边有权值，而AOV网中的边无权值，仅表示顶点之间的前后关系；</p><p>AOE网有如下性质：</p><ul><li>在某顶点代表事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>在进入某顶点的各有向边所代表的的活动都已结束后，该顶点所代表的的事件才能发生；</li></ul><p>相关概念：顶点（源点），结束顶点（汇点）；<strong>路径长度</strong>指各个活动所持续的时间之和；<strong>关键路径</strong>指从源点到汇点具有最大长度的路径，同时在关键路径上的活动称之为<strong>关键活动</strong>；<br>未完待续……</p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>两顶点之间经过的边上权值之和最小的路径，且称路径上的第一个顶点为源点，最后一个顶点为终点；</p><h3 id="迪杰斯特拉算法-Dijkstra"><a href="#迪杰斯特拉算法-Dijkstra" class="headerlink" title="迪杰斯特拉算法(Dijkstra)"></a>迪杰斯特拉算法(Dijkstra)</h3><h3 id="弗洛伊德算法-Floyd"><a href="#弗洛伊德算法-Floyd" class="headerlink" title="弗洛伊德算法(Floyd)"></a>弗洛伊德算法(Floyd)</h3><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree</title>
      <link href="/2023/02/13/tree/"/>
      <url>/2023/02/13/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><p>基本概念：子树，度，叶子（终端节点），分支节点（非终端节点），孩子，双亲，兄弟，子孙……<br>节点<strong>层次</strong>：注意从根开始定义，根为第一层;<br>树的<strong>深度（高度）</strong>：树中节点的最大层次；<br>以及如节点各子树有次序，称其为<strong>有序树</strong>，否则为<strong>无序树</strong>；<br><strong>森林</strong>为n棵互不相交的树的集合；  </p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>二叉树</strong>是一种树形结构，各个节点至多只有两棵子树，且各子树有次序，为有序树；  </p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>顺序存储结构<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_TREE_SIZE 100                   &#x2F;&#x2F;二叉树最大节点数typedef TElemType SqBiTree[MAX_TREE_SIZE];  &#x2F;&#x2F;0号存储根节点SqBiTree bt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>链式存储结构<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct BiTNode&#123;  TElemType data;  struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="遍历二叉树及线索二叉树"><a href="#遍历二叉树及线索二叉树" class="headerlink" title="遍历二叉树及线索二叉树"></a>遍历二叉树及线索二叉树</h2><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>首先标明三种概念，<strong>先序遍历</strong>，<strong>中序遍历</strong>，以及<strong>后序遍历</strong>。实际上，其分别对应于波兰式，中缀表达式，逆波兰式；  </p><ul><li>先序：根-&gt;左-&gt;右</li><li>中序：左-&gt;根-&gt;右</li><li>后序：左-&gt;右-&gt;根</li></ul><p>可以均从左向右历遍，根据经过该节点的次数判断是否遍历，首先经过，即先序，历遍该节点的左子树后，再次经过该节点，即中序，再历遍右子树后返回该节点，即后序；</p><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>以先序遍历为例，如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status PreOrderTraverse(BiTree T, Status (*Visit)(TElemType e))&#123;  if (T)  &#123;    if (T-&gt;data)    &#123;      if (PreOrderTraverse(T-&gt;lchild, Visit))      &#123;        if (PreOrderTraverse(T-&gt;rchild, Visit))          return OK;      &#125;    &#125;    return ERROR;  &#125;  else    return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中序遍历以及后序遍历即将根节点的访问置于中间或最后，在此不做赘述；  </p><h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><ul><li>中序遍历的非递归算法<pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InOrderTraverse(BiTree T, Status (*Visit)(TElemType e))&#123;  SqStack *S &#x3D; (SqStack *)malloc(sizeof(SqStack));  InitStack(S);  Push(S, T);  while (!StackEmpty(*S))  &#123;    BiTNode *p &#x3D; (BiTNode *)malloc(sizeof(BiTNode));    while (GetTop(*S, p) &amp;&amp; p)      Push(S, p-&gt;lchild);    Pop(S, p);    if (!StackEmpty(*S))    &#123;      Pop(S, p);      if (!Visit(p-&gt;data))        return ERROR;      Push(S, p-&gt;rchild);    &#125;  &#125;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>另一种形式如下：  <pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InOrder_Traverse(BiTree T, Status (*Visit)(TElemType e))&#123;  SqStack *S &#x3D; (SqStack *)malloc(sizeof(SqStack));  InitStack(S);  BiTNode *p &#x3D; T;  while (p || !StackEmpty(*S))  &#123;    if (p)    &#123; &#x2F;&#x2F; 根指针进栈，遍历左子树      Push(S, p);      p &#x3D; p-&gt;lchild;    &#125;    else    &#123; &#x2F;&#x2F; 根指针退栈，遍历右子树      Pop(S, p);      if (!Visit(p-&gt;data))        return ERROR;      p &#x3D; p-&gt;rchild;    &#125;  &#125;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>两种方法均在于在于每次向左历遍后退栈空指针，进行中序遍历访问，再向右一步进行继续历遍；</li><li>先序遍历的非递归算法</li></ul><p>相较于中序遍历，先序遍历的非递归算法仅仅改变了访问节点的时刻；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status PreOrder_Traverse(BiTree T, Status (*Visit)(TElemType e))&#123;  SqStack *S &#x3D; (SqStack *)malloc(sizeof(SqStack));  InitStack(S);  BiTNode *p &#x3D; T;  while (p || !StackEmpty(*S))  &#123;    if (p)    &#123;      if (!Visit(p-&gt;data))        return ERROR;      Push(S, p);      p &#x3D; p-&gt;lchild;    &#125;    else    &#123;      Pop(S, p);      p &#x3D; p-&gt;rchild;    &#125;  &#125;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>后序遍历的非递归算法</li></ul><p>其中主要是根据右子树以及是否访问过进行出栈访问的判断，要注意存在一个r标志，表示该节点已被访问过，相当于该节点的父节点的右子树为空；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status PostOrder_Traverse(BiTree T, Status (*Visit)(TElemType e))&#123;  SqStack *S &#x3D; (SqStack *)malloc(sizeof(SqStack));  InitStack(S);  BiTNode *p &#x3D; T, *r &#x3D; NULL;  while (p || !StackEmpty(*S))  &#123;    if (p)    &#123; &#x2F;&#x2F; 同样先遍历左子树      Push(S, p);      p &#x3D; p-&gt;lchild;    &#125;    else    &#123; &#x2F;&#x2F; 先不出栈，根据栈顶元素的右子树情况进行判断      GetTop(*S, p);      if (p-&gt;rchild &amp;&amp; p-&gt;rchild !&#x3D; r)      &#123; &#x2F;&#x2F; 如果右子树存在，并且未被访问过        p &#x3D; p-&gt;rchild;        Push(S, p);        p &#x3D; p-&gt;lchild;      &#125;      else      &#123; &#x2F;&#x2F; 否则便可以直接出栈并访问        Pop(S, p);        if (!Visit(p-&gt;data))          return ERROR;        r &#x3D; p;    &#x2F;&#x2F; 标记该节点已被访问，便于其父节点判断        p &#x3D; NULL; &#x2F;&#x2F; 修改p,直接跳入对其父节点判断      &#125;    &#125;  &#125;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>对于层次遍历，需要借助一个队列，先将二叉树根节点入队，然后出队访问，将其左右子树根节点入队，循环以上过程，直至队列为空……</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status LevelOrder(BiTree T)&#123;  SqQueue *Q &#x3D; (SqQueue *)malloc(sizeof(SqQueue));  InitQueue(Q);  BiTree p;  EnQueue(Q, T);  while (!(Q-&gt;front &#x3D;&#x3D; Q-&gt;rear))  &#123; &#x2F;&#x2F;若队列不空    DeQueue(Q, p);    Visit(p);    if (p-&gt;lchild !&#x3D; NULL)      EnQueue(Q, p-&gt;lchild);  &#x2F;&#x2F;左子树    if (p-&gt;rchild !&#x3D; NULL)      EnQueue(Q, p-&gt;rchild);  &#x2F;&#x2F;右子树  &#125;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h4><ul><li><p>先序序列和中序序列确定二叉树</p><p>在中序序列中找到依次找到先序序列中元素作为根节点，则该节点左侧所有元素即属于左子树，同理，右侧均属于右子树；</p></li><li><p>后序序列和中序序列确定二叉树  </p><p>同样是分割中序序列，由后序序列的最后一个节点如同先序序列的第一个节点，构造二叉树；</p></li><li><p>层序序列和中序序列确定二叉树</p><p>由层序序列同样可以得到各子树根节点，由此分割中序序列得到二叉树；</p></li></ul><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>试作如下规定：若节点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱；若节点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。<br>根据此改变节点结构，增加两个标志域如下：</p><p>$$LTag &#x3D; \begin{cases}<br>0,lchild域指示节点的左孩子<br>\1,lchild域指示节点的前驱<br>\end{cases}$$<br>$$LTag &#x3D; \begin{cases}<br>0,rchild域指示节点的右孩子<br>\1,lrchild域指示节点的后继<br>\end{cases}$$</p><p>以此节点结构构成的二叉链表作为二叉树的存储结构，称其为<strong>线索链表</strong>，指向节点前驱和后级的指针称为<strong>线索</strong>，加上线索的二叉树称之为<strong>线索二叉树</strong>，对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong>；</p><h4 id="存储表示"><a href="#存储表示" class="headerlink" title="存储表示"></a>存储表示</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef enum PointerTag&#123;  Link,  Thread&#125;;typedef struct BiThrNode&#123;  TElemType data;  struct BiThrNode *lchild, *rchild;  PointerTag LTag, RTag; &#x2F;&#x2F; 左右标志&#125; BiThrNode, *BiThrTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时仿照线性表的存储结构，在二叉树线索链表上添加一个头结点，其lchild域的指针指向二叉树的根节点，其rchild域的指针指向中序遍历时访问的最后一个节点；同时中序序列中的第一个节点的lchild域指针和最后一个节点的rchild域指针均指向头结点；</p><h4 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h4><ul><li>中序遍历二叉线索树</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InOrderTraverse_Thr(BiThrTree T, Status (*Visit)(TElemType))&#123; &#x2F;&#x2F; 中序遍历二叉线索树T的非递归算法  BiThrNode *p &#x3D; T-&gt;lchild; &#x2F;&#x2F; T为头结点，p指向树的根节点  while (p !&#x3D; T)  &#123;    while (p-&gt;LTag &#x3D;&#x3D; Link)      p &#x3D; p-&gt;lchild;    if (!Visit(p-&gt;data))      return ERROR;    while (p-&gt;RTag &#x3D;&#x3D; Thread &amp;&amp; p-&gt;rchild !&#x3D; T)    &#123; &#x2F;&#x2F;访问后继节点，直到存在右子树的节点或指向头指针的节点      p &#x3D; p-&gt;rchild;      Visit(p-&gt;data);    &#125;    p &#x3D; p-&gt;rchild;    &#x2F;&#x2F;对其右子树再次中序遍历  &#125;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h4><ul><li>中序遍历二叉树，并将其中序线索化</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InOrderThreading(BiThrTree *Thrt, BiThrTree T)&#123;  if (!(Thrt &#x3D; (BiThrTree *)malloc(sizeof(BiThrTree))))    return ERROR;  (*Thrt)-&gt;LTag &#x3D; Link;  (*Thrt)-&gt;RTag &#x3D; Thread; &#x2F;&#x2F; 建立头结点  (*Thrt)-&gt;rchild &#x3D; Thrt; &#x2F;&#x2F; 右指针回指  if (!T)    (*Thrt)-&gt;lchild &#x3D; Thrt; &#x2F;&#x2F; 若二叉树空则左指针同样回指  else  &#123;    (*Thrt)-&gt;lchild &#x3D; T;    BiThrNode *pre &#x3D; Thrt;    InThreading(T, pre);    pre-&gt;rchild &#x3D; Thrt;    pre-&gt;RTag &#x3D; Thread;    (*Thrt)-&gt;rchild &#x3D; pre;  &#125;  return OK;&#125;void InThreading(BiThrTree p, BiThrNode *pre)&#123;  if (p)  &#123;    InThreading(p-&gt;lchild, pre); &#x2F;&#x2F; 左子树线索化    if (!p-&gt;lchild)    &#123; &#x2F;&#x2F; 前驱线索      p-&gt;LTag &#x3D; Thread;      p-&gt;lchild &#x3D; pre;    &#125;    if (!pre-&gt;rchild)    &#123; &#x2F;&#x2F; 后继线索      pre-&gt;RTag &#x3D; Thread;      pre-&gt;rchild &#x3D; p;    &#125;    pre &#x3D; p;     &#x2F;&#x2F;保持前驱更新    InThreading(p-&gt;rchild, pre); &#x2F;&#x2F; 右子树线索化  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中InThreading算法类似于中序遍历的递归算法，仅将访问节点改为了实现线索化；</p><ul><li>先序和后序线索化二叉树<br>类似于中序线索化二叉树，将递归算法中访问功能更改为线索化实现，即可得到相应的线索化算法；</li></ul><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>如下有三种常用的链表结构：</p><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_TREE_SIZE 100typedef struct PTNode&#123; &#x2F;&#x2F; 节点结构  TElemType data;  int parent; &#x2F;&#x2F; 双亲位置域&#125; PTNode;typedef struct&#123;  PTNode nodes[MAX_TREE_SIZE];  int r, n; &#x2F;&#x2F; 根的位置和节点数&#125; PTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种结构利用了各节点（除根外）仅有一个双亲的性质；根据此性质便于实现对于父节点的查找，但是要求节点的孩子时则需要遍历整个结构；</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct CTNode&#123; &#x2F;&#x2F; 孩子节点  int child;  struct CTNode *next;&#125; *ChildPtr;typedef struct&#123;  TElemType data;  ChildPtr firstchild; &#x2F;&#x2F; 孩子链表头指针&#125; CTBox;typedef struct&#123;  CTBox nodes[MAX_TREE_SIZE];  int n, r; &#x2F;&#x2F; 节点数和根的位置&#125; CTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似于双亲表示法，孩子表示法便于实现关于孩子的操作，考虑到两种方式的优劣性，故可拓展为带双亲的孩子链表；</p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>或称<strong>二叉树表示法，二叉链表表示法</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct CSNode&#123;  TElemType data;  struct CSNode *firstchild, *nextsibling;&#125; CSNode, *CSTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树-amp-森林-amp-二叉树"><a href="#树-amp-森林-amp-二叉树" class="headerlink" title="树&amp;森林&amp;二叉树"></a>树&amp;森林&amp;二叉树</h2><h3 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h3><p>由上述的二叉链表表示法可导出树与二叉树之间的一个对应关系，由此引出如下的转换方式：<br><strong>森林-&gt;二叉树</strong></p><ul><li>在兄弟节点之间加一条线（各树根可视作兄弟关系）；</li><li>对于每个节点，只保留其与第一个孩子的连线，其与抹除；</li><li>以树根为轴心，顺时针旋转45度；</li></ul><p><strong>二叉树-&gt;森林</strong></p><p>类似于如上的逆过程……</p><h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><p><strong>树的遍历</strong></p><ul><li>先根遍历：先访问树的根节点，然后一次先根遍历根的每棵子树；（类似先序）</li><li>后根遍历：先依次后根遍历每棵子树，然后访问根节点；（类似中序）</li></ul><p><strong>森林的遍历</strong></p><ul><li>先序遍历森林：第一棵树的根节点-&gt;先序遍历第一棵树中根节点的子树森林-&gt;先序遍历除第一棵树所构成的森林；</li><li>后序遍历森林：第一棵树的根节点的子树森林-&gt;访问第一棵树的根节点-&gt;后序遍历除第一棵树所构成的森林;</li></ul><h2 id="树与等价问题"><a href="#树与等价问题" class="headerlink" title="树与等价问题"></a>树与等价问题</h2><h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>考虑到带权路径长度的概念，引出如下的<strong>huffman树</strong>或<strong>最优二叉树</strong>；  </p><ul><li>树的<strong>路径长度</strong>是从树根到每一节点的路径长度之和；  </li><li>树的<strong>带权路径长度</strong>为树中所有叶子节点的带权路径长度之和，记作<br>$$ WPL &#x3D; \sum_{k&#x3D;1}^{n}w_{k}l_{k}  $$</li></ul><h3 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h3><p>根据huffman树的原理使得二进制前缀编码的权重和最小，有如下实现：</p><h4 id="存储表示-1"><a href="#存储表示-1" class="headerlink" title="存储表示"></a>存储表示</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define OK 1#define ERROR -1#define MAX_FILENAME 100 &#x2F;&#x2F; 文件名最大长度#define MAX_NUM 9999999&#x2F;&#x2F; 统计字符频度的临时结点typedef struct&#123;  unsigned char str;   &#x2F;&#x2F; 存储该节点对应字符  unsigned int weight; &#x2F;&#x2F; 该字符频度&#125; StrNode;&#x2F;&#x2F; 哈夫曼树结点typedef struct&#123;  unsigned char str;          &#x2F;&#x2F; 以8bits为单元的无符号字符  unsigned int weight;        &#x2F;&#x2F; 每类（以二进制编码区分）字符出现频度  char *code;                 &#x2F;&#x2F; 字符对应的哈夫曼编码（动态分配存储空间）  int parent, lchild, rchild; &#x2F;&#x2F; 定义双亲和左右孩子&#125; HufNode, *HufTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 选择最小的两个结点void select(HufNode *huftree, unsigned int n, int *s1, int *s2)&#123;  unsigned int i;  unsigned int min &#x3D; MAX_NUM; &#x2F;&#x2F; 初始化最小值  for (i &#x3D; 0; i &lt; n; ++i)    if (huftree[i].parent &#x3D;&#x3D; 0 &amp;&amp; huftree[i].weight &lt; min)    &#123;      &#x2F;&#x2F; 选择父节点未被标记以及权重最小的节点      min &#x3D; huftree[i].weight;      *s1 &#x3D; i;    &#125;  huftree[*s1].parent &#x3D; 1; &#x2F;&#x2F; 标记该节点已有父节点  min &#x3D; MAX_NUM;           &#x2F;&#x2F; 重新初始化便于寻找  for (i &#x3D; 0; i &lt; n; ++i)    if (huftree[i].parent &#x3D;&#x3D; 0 &amp;&amp; huftree[i].weight &lt; min)    &#123;      &#x2F;&#x2F; 选择父节点未被标记以及权重第二小的节点      min &#x3D; huftree[i].weight;      *s2 &#x3D; i;    &#125;&#125;&#x2F;&#x2F; 建立赫夫曼树以及赫夫曼编码void HuffmanCoding(HufNode *huftree, unsigned int kinds)&#123;  unsigned int i;  int s1, s2;  for (i &#x3D; kinds; i &lt; 2 * kinds - 1; i++)  &#123; &#x2F;&#x2F; 建立Huffman树    select(huftree, i, &amp;s1, &amp;s2);    &#x2F;&#x2F; 找到最小的两个节点    huftree[s1].parent &#x3D; huftree[s2].parent &#x3D; i;    huftree[i].lchild &#x3D; s1;    huftree[i].rchild &#x3D; s2;    huftree[i].weight &#x3D; huftree[s1].weight + huftree[s2].weight;  &#125;  &#x2F;&#x2F; 构建Huffman编码  int c, f, start;  char *cd &#x3D; (char *)malloc(kinds * sizeof(char)); &#x2F;&#x2F; 存储编码kinds种  cd[kinds - 1] &#x3D; &#39;\0&#39;;                            &#x2F;&#x2F; 编码结束符  for (i &#x3D; 0; i &lt; kinds; ++i)  &#123; &#x2F;&#x2F; 逐个字符求其对应的Huffman编码    start &#x3D; kinds - 1;                                                       &#x2F;&#x2F; 编码结束符位置    for (c &#x3D; i, f &#x3D; huftree[i].parent; f !&#x3D; 0; c &#x3D; f, f &#x3D; huftree[f].parent) &#x2F;&#x2F; 从叶子到根逆向求编码      if (huftree[f].lchild &#x3D;&#x3D; c)        cd[--start] &#x3D; &#39;0&#39;; &#x2F;&#x2F; 左子树为0      else        cd[--start] &#x3D; &#39;1&#39;; &#x2F;&#x2F; 右子树为1    huftree[i].code &#x3D; (char *)malloc((kinds - start) * sizeof(char)); &#x2F;&#x2F; 为第i个字符编码分配存储空间    strcpy(huftree[i].code, &amp;cd[start]);                              &#x2F;&#x2F; 从cd复制编码串到编码域  &#125;  free(cd); &#x2F;&#x2F; 释放工作空间&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>或是空树，或满足下列条件：</p><ul><li>若它的左子树不空，则左子树所有节点的值均小于它根节点的值；</li><li>若它的右子树不空，则右子树所有节点的值均大于它根节点的值；</li><li>它的左右子树也分别为二叉排序树；</li></ul><p>其类型定义可类似于二叉链表如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct BiTNode&#123;  int data;  struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SearchBST"><a href="#SearchBST" class="headerlink" title="SearchBST"></a>SearchBST</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">BiTree SearchBST(BiTree T, keyType key)&#123; &#x2F;&#x2F;二叉排序树查找算法  if ((!T) || key &#x3D;&#x3D; T-&gt;data)    return T;  else if (key &lt; T-&gt;data) &#x2F;&#x2F; 关键字在左子树上    return SearchBST(T-&gt;lchild, key);  else    return SearchBST(T-&gt;rchild, key);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="InsertBST"><a href="#InsertBST" class="headerlink" title="InsertBST"></a>InsertBST</h3><p>在原有的查找算法中进行改进，用指针p返回访问时的最后的一个节点，便于最后进行插入；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status SearchBST(BiTree T, keyType key, BiTree f, BiTree *p)&#123; &#x2F;&#x2F; 二叉排序树查找算法，p指向访问路径的最后一个节点  if (!T)  &#123;    p &#x3D; f;    return ERROR;  &#125;  else if (key &#x3D;&#x3D; T-&gt;data)  &#123;    p &#x3D; T;    return OK;  &#125;  else if (key &lt; T-&gt;data)    return SearchBST(T-&gt;lchild, key, T, p);  else    return SearchBST(T-&gt;rchild, key, T, p);&#125;Status InsertBST(BiTree *T, int e)&#123; &#x2F;&#x2F; 当二叉排序树中不存在关键字为e的数据元素是，插入并返回OK  BiTree p &#x3D; (BiTree)malloc(sizeof(BiTNode));  if (!SearchBST(T, e, NULL, &amp;p))  &#123;    BiTree s &#x3D; (BiTree)malloc(sizeof(BiTNode));    s-&gt;data &#x3D; e;    s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;    &#x2F;&#x2F; 此时根据查找时访问的最后一个节点插入    if (!p)      *T &#x3D; s;    else if (e &lt; p-&gt;data)      p-&gt;lchild &#x3D; s;    else      p-&gt;rchild &#x3D; s;    return OK;  &#125;  else    return ERROR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DeleteBST"><a href="#DeleteBST" class="headerlink" title="DeleteBST"></a>DeleteBST</h3><p>其中Delete函数实现对于节点的删除以及左右子树的重连；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DeleteBST(BiTree *T, keyType key)&#123; &#x2F;&#x2F; 删除关键字为key元素  if (!*T)    return ERROR;  else  &#123;    if (key &#x3D;&#x3D; (*T)-&gt;data) &#x2F;&#x2F; 进行删除      return Delete(T);    else if (key &lt; (*T)-&gt;data) &#x2F;&#x2F; 对左子树进行查找      return DeleteBST((*T)-&gt;lchild, key);    else      return DeleteBST((*T)-&gt;rchild, key);  &#125;  return OK;&#125;Status Delete(BiTree *p)&#123; &#x2F;&#x2F; 删除节点p，并重连它的左右子树  BiTree q &#x3D; (BiTree *)malloc(sizeof(BiTree));  BiTree s &#x3D; (BiTree *)malloc(sizeof(BiTree));  if (!(*p)-&gt;rchild)  &#123; &#x2F;&#x2F; 重接左子树    q &#x3D; *p;    *p &#x3D; (*p)-&gt;lchild;    free(q);  &#125;  else if (!(*p)-&gt;lchild)  &#123; &#x2F;&#x2F; 重接右子树    q &#x3D; *p;    *p &#x3D; (*p)-&gt;rchild;    free(q);  &#125;  else  &#123;    q &#x3D; *p;    s &#x3D; (*p)-&gt;lchild; &#x2F;&#x2F; 先向左    while (s-&gt;rchild)    &#123; &#x2F;&#x2F; 再向右到尽头，找到待删节点的前驱      q &#x3D; s;      s &#x3D; s-&gt;rchild;    &#125;    (*p)-&gt;data &#x3D; s-&gt;data; &#x2F;&#x2F; 将待删节点的值换为其前驱的值    &#x2F;&#x2F;分别重接q的左右子树    if (q !&#x3D; *p)      q-&gt;rchild &#x3D; s-&gt;lchild;    else      q-&gt;lchild &#x3D; s-&gt;lchild;    delete (s); &#x2F;&#x2F;删除前驱结点  &#125;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><strong>平衡二叉树</strong>是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1；则显然，其要么是一颗空树，要么它的左右子树均是平衡二叉树，且深度之差绝对值不超过1；同时我们将二叉树上节点的左子树深度减去右子树深度的值称为**平衡因子BF(Balance Factor)**，则所有节点的平衡因子只可能是-1，0，1；</p><h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><h3 id="平衡二叉树的查找"><a href="#平衡二叉树的查找" class="headerlink" title="平衡二叉树的查找"></a>平衡二叉树的查找</h3><h2 id="B-树和B-树"><a href="#B-树和B-树" class="headerlink" title="B-树和B+树"></a>B-树和B+树</h2><h2 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h2><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2023/01/20/string/"/>
      <url>/2023/01/20/string/</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>串（字符串）是由零个或多个字符组成的有限序列；</p><ul><li><strong>串的长度</strong>：串中字符数目n称为<strong>串的长度</strong>；</li><li><strong>空串</strong>：零个字符的串称为<strong>空串</strong>，长度为零；</li><li><strong>子串</strong>：串中任意个连续的字符组成的子序列称为该串的<strong>子串</strong>；</li><li><strong>主串</strong>：包含子串的串相应地称为<strong>主串</strong>；</li><li><strong>位置</strong>：字符在序列中的序号为该字符在串中的<strong>位置</strong>；</li></ul><p><strong>抽象数据类型</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">StrAssign(&amp;T, chars)          &#x2F;&#x2F;生成一个其值为chars的串TStrCopy(&amp;T, S)                &#x2F;&#x2F;由串S复制得串TStrEmpty(S, T)                &#x2F;&#x2F;若S为空串，则返回TRUE，否则返回FALSEStrCompare(S, T)              &#x2F;&#x2F;S &gt; T，返回值大于0；S &#x3D; T，返回值等于0； S &lt; T，返回值小于0 StrLength(S)                  &#x2F;&#x2F;返回S的元素个数，称为串的长度ClearString(&amp;S)               &#x2F;&#x2F;将S清为空串Concat(&amp;T, S1, S2)            &#x2F;&#x2F;T返回S1和S2连接的新串SubString(&amp;Sub, S, pos, len)  &#x2F;&#x2F;Sub返回串S的第pos个字符起长度为len的子串Index(S, T, pos)              &#x2F;&#x2F;返回主串S中第pos个字符之后第一次出现与串T相同的子串的位置，无则返回0Replace(&amp;S, T, V)             &#x2F;&#x2F;用V替换主串S中出现的所有与T相等的不重叠的子串StrInsert(&amp;S, pos, T)         &#x2F;&#x2F;在串S的pos个字符之前插入串TStrDelete(&amp;S, pos, len)       &#x2F;&#x2F;从串S中删除第pos个字符起长度为len的子串DestoryString(&amp;S)             &#x2F;&#x2F;销毁串S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述13中操作中，StrAssign,StrCompare,StrLength,Concat,SubString五种操作构成串类型的最小操作子集；<br>如下根据最小操作子集实现Index操作：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int Index(String S, String T, int pos)&#123;  if(pos &gt; 0)  &#123;    int n &#x3D; StrLength(S);    int m &#x3D; StrLength(T);    int i &#x3D; pos;    String sub;    while(i &lt;&#x3D; n - m + 1)    &#123; &#x2F;&#x2F;从S的pos位置后依次取T长度个的子串进行比较      SubString(sub, S, i, m);      if(StrCompare(sub, T) !&#x3D; 0)        i++;      else         return i;    &#125;  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="串的表示及实现"><a href="#串的表示及实现" class="headerlink" title="串的表示及实现"></a>串的表示及实现</h2><h3 id="定长顺序存储结构"><a href="#定长顺序存储结构" class="headerlink" title="定长顺序存储结构"></a>定长顺序存储结构</h3><p>用一组地址连续的储存单元存储，如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSTRLEN 255#define OK 1#define ERROR 0typedef int Status;typedef unsigned char SString[MAXSTRLEN + 1]; &#x2F;&#x2F;0号单元存放串的长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h4><h3 id="堆分配存储结构"><a href="#堆分配存储结构" class="headerlink" title="堆分配存储结构"></a>堆分配存储结构</h3><p>仍采用一组地址连续的储存单元存放，但存储空间采取动态分配，如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct&#123;  char *ch;  int length;&#125;HString;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h3><h3 id="块链存储结构"><a href="#块链存储结构" class="headerlink" title="块链存储结构"></a>块链存储结构</h3><p>采取链表形式存储串值，用户自定义节点即块的大小，称之为块链结构；  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define CHUNKSIZE 80  &#x2F;&#x2F;自定义块的大小typedef struct Chunk&#123;  char ch[CHUNKSIZE];  struct Chunk *next;&#125;Chunk;typedef struct&#123;  Chunk *head, *tail; &#x2F;&#x2F;串的头尾指针  int curlen;         &#x2F;&#x2F;当前长度&#125;LString;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><h3 id="求子串位置的定位函数Index-S-T-pos"><a href="#求子串位置的定位函数Index-S-T-pos" class="headerlink" title="求子串位置的定位函数Index(S, T, pos)"></a>求子串位置的定位函数Index(S, T, pos)</h3><p>子串的定位操作称作串的<strong>模式匹配</strong>，其中T称为<strong>模式串</strong>；<br>如下采取定长顺序存储结构，实现不依赖其他串操作的匹配算法：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int Index(SString S, SString T, int pos)&#123; &#x2F;&#x2F;返回子串T在主串S中第pos个字符之后的位置，若不存在，返回0  int i &#x3D; pos, j &#x3D; 1;  while(i &lt;&#x3D; S[0] &amp;&amp; j &lt;&#x3D; T[0])  &#123;    if(S[i] &#x3D;&#x3D; T[j])    &#123;      i++;      j++;    &#125;    else    &#123; &#x2F;&#x2F;指针回退，重新匹配      i &#x3D; i - j + 2;      j &#x3D; 1;    &#125;  &#125;  if(j &gt; T[0])    return i - T[0];  else     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过，有些情况下，该算法的效率较低，比如模式串为 00000001 ，主串为 00000000000000000000000000000000000000000000000000001 时，时间复杂度达到O(n*m);</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h2 id="串的应用"><a href="#串的应用" class="headerlink" title="串的应用"></a>串的应用</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue</title>
      <link href="/2023/01/20/queue/"/>
      <url>/2023/01/20/queue/</url>
      
        <content type="html"><![CDATA[<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>队列是一种先进先出(first in first out FIFO)的线性表，只允许在表的一端插入元素，另一端删除；允许插入的一端称为队尾，允许删除的一端称为队头；<br><strong>抽象数据类型</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">InitQueue(&amp;Q)               &#x2F;&#x2F;构造空队列QDestroyQueue(&amp;Q)            &#x2F;&#x2F;销毁队列QClearQueue(&amp;Q)              &#x2F;&#x2F;将Q清为空队列QueueEmpty(&amp;Q)              &#x2F;&#x2F;若Q为空队列，返回TRUE，否则FALSEQueueLength(Q)              &#x2F;&#x2F;返回Q的元素个数，即队列长度GetHead(Q, &amp;e)              &#x2F;&#x2F;用e返回Q的队头元素EnQueue(&amp;Q, e)              &#x2F;&#x2F;插入元素e为新的队尾元素DeQueue(&amp;Q, &amp;e)             &#x2F;&#x2F;删除Q的队头元素，并用e返回其值QueueTraverse(Q, visit())   &#x2F;&#x2F;从队头到队尾，依次对Q的每个数据元素调用函数visit()，visit()失败，操作失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>若采取顺序栈的结构将会造成假溢出，将顺序栈的结构改善为环状空间，可充分利用分配的存储空间，称之为循环队列；<br>注意此时仅凭借Q-&gt;front &#x3D;&#x3D; Q-&gt;rear并不能判断队列空间为“空”还是“满”，可有如下处理方法：  </p><ul><li>设置一个标志位以区别队列为“空”还是“满”；</li><li>减少一个元素空间的使用，队列头指针在队列尾指针的下一位置作为队列“满”的标志；</li></ul><p>在这里采取第二种处理方式，Q-&gt;front &#x3D;&#x3D; Q-&gt;rear仅作为队列空的标志；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXQSIZE 100typedef int QElemType;typedef struct &#123;  QElemType *base;  &#x2F;&#x2F;初始化的动态分配存储空间  int front;        &#x2F;&#x2F;头指针，若不空，指向队列头元素  int rear;         &#x2F;&#x2F;尾指针，若不空，指向队列尾元素的下一个位置&#125;SqQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="InitQueue"><a href="#InitQueue" class="headerlink" title="InitQueue"></a>InitQueue</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitQueue(SqQueue *Q)&#123; &#x2F;&#x2F; 构造空队列  Q-&gt;base &#x3D; (QElemType *)malloc(MAXQSIZE * sizeof(QElemType));  if (!Q-&gt;base)    return ERROR;  Q-&gt;front &#x3D; Q-&gt;rear &#x3D; 0;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="QueueLength"><a href="#QueueLength" class="headerlink" title="QueueLength"></a>QueueLength</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int QueueLength(SqQueue Q)&#123; &#x2F;&#x2F; 返回队列长度  return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;  &#x2F;&#x2F; 考虑到相减后结果可能是负数，因此要加上MAXQSIZE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="EnQueue"><a href="#EnQueue" class="headerlink" title="EnQueue"></a>EnQueue</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status EnQueue(SqQueue *Q, QElemType e)&#123; &#x2F;&#x2F; 插入新的队尾元素e  &#x2F;&#x2F; 队列满  if ((Q-&gt;rear + 1) % MAXQSIZE &#x3D;&#x3D; Q-&gt;front)    return ERROR;  Q-&gt;base[Q-&gt;rear] &#x3D; e;  Q-&gt;rear &#x3D; (Q-&gt;rear + 1) % MAXQSIZE;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DeQueue"><a href="#DeQueue" class="headerlink" title="DeQueue"></a>DeQueue</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DeQueue(SqQueue *Q, QElemType *e)&#123; &#x2F;&#x2F; 删除队头元素，并用e返回其值  if (Q-&gt;front &#x3D;&#x3D; Q-&gt;rear)    return ERROR;  *e &#x3D; Q-&gt;base[Q-&gt;front];  Q-&gt;front &#x3D; (Q-&gt;front + 1) % MAXQSIZE;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;  SqQueue *Q &#x3D; (SqQueue *)malloc(sizeof(SqQueue));  InitQueue(Q);  EnQueue(Q, 1);  printf(&quot;%d %d %d\n&quot;, Q-&gt;base[Q-&gt;front], Q-&gt;base[Q-&gt;rear - 1], QueueLength(*Q));  EnQueue(Q, 2);  printf(&quot;%d %d %d\n&quot;, Q-&gt;base[Q-&gt;front], Q-&gt;base[Q-&gt;rear - 1], QueueLength(*Q));  int *e &#x3D; (int *)malloc(sizeof(int));  DeQueue(Q, e);  printf(&quot;%d %d %d\n&quot;, Q-&gt;base[Q-&gt;front], Q-&gt;base[Q-&gt;rear - 1], QueueLength(*Q));  printf(&quot;%d\n&quot;, *e);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>单链队列，队列的链式存储结构，链队列同时也添加一个头结点，并令头指针指向头结点，头指针与尾指针均指向头结点即空的链队列的判定条件；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef int QElemType;typedef struct QNode&#123;  QElemType data;  struct QNode *next;&#125;QNode, *QueuePtr;typedef struct&#123;  QueuePtr front;   &#x2F;&#x2F;队头  QueuePtr rear;    &#x2F;&#x2F;队尾&#125;LinkQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="InitQueue-1"><a href="#InitQueue-1" class="headerlink" title="InitQueue"></a>InitQueue</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitQueue(LinkQueue *Q)&#123; &#x2F;&#x2F; 构造空队列Q  Q-&gt;front &#x3D; Q-&gt;rear &#x3D; (QueuePtr)malloc(sizeof(QNode));  if (!Q-&gt;front)    return ERROR;  Q-&gt;front-&gt;next &#x3D; NULL;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DestoryQueue"><a href="#DestoryQueue" class="headerlink" title="DestoryQueue"></a>DestoryQueue</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DestoryQueue(LinkQueue *Q)&#123; &#x2F;&#x2F; 销毁队列Q  while (Q-&gt;front)  &#123; &#x2F;&#x2F; 从队头向后依次销毁    Q-&gt;rear &#x3D; Q-&gt;front-&gt;next;    free(Q-&gt;front);    Q-&gt;front &#x3D; Q-&gt;rear;  &#125;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="EnQueue-1"><a href="#EnQueue-1" class="headerlink" title="EnQueue"></a>EnQueue</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status EnQueue(LinkQueue *Q, QElemType e)&#123; &#x2F;&#x2F; 插入元素e为新的队尾元素  QueuePtr p &#x3D; (QueuePtr)malloc(sizeof(QNode));  if (!p)    return ERROR;  p-&gt;data &#x3D; e;  p-&gt;next &#x3D; NULL;  Q-&gt;rear-&gt;next &#x3D; p;  Q-&gt;rear &#x3D; p; &#x2F;&#x2F; 更新队尾指针  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DeQueue-1"><a href="#DeQueue-1" class="headerlink" title="DeQueue"></a>DeQueue</h4><p>注意队头指针指向头结点，需要删除的是Q-&gt;front-&gt;next该节点；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status DeQueue(LinkQueue *Q, QElemType *e)&#123; &#x2F;&#x2F; 删除队头元素，并用e返回其值  if (Q-&gt;front &#x3D;&#x3D; Q-&gt;rear)    return ERROR;  QueuePtr p &#x3D; (QueuePtr)malloc(sizeof(QNode));  p &#x3D; Q-&gt;front-&gt;next;  Q-&gt;front-&gt;next &#x3D; p-&gt;next; &#x2F;&#x2F; 无需修改头结点  if (Q-&gt;rear &#x3D;&#x3D; p)    Q-&gt;rear &#x3D; Q-&gt;front;  free(p);  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;  LinkQueue *Q &#x3D; (LinkQueue *)malloc(sizeof(LinkQueue));  InitQueue(Q);  EnQueue(Q, 1);  printf(&quot;%d %d\n&quot;, Q-&gt;front-&gt;next-&gt;data, Q-&gt;rear-&gt;data);  EnQueue(Q, 2);  printf(&quot;%d %d\n&quot;, Q-&gt;front-&gt;next-&gt;data, Q-&gt;rear-&gt;data);  int *e &#x3D; (int *)malloc(sizeof(int));  DeQueue(Q, e);  printf(&quot;%d %d\n&quot;, Q-&gt;front-&gt;next-&gt;data, Q-&gt;rear-&gt;data);  DestoryQueue(Q);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列(double ended queue, deque)是限定插入和删除操作在表的两端进行的线性表；<br>在实际使用中还有，输出受限的双端队列（一个端点允许插入删除，另一个端点只允许插入），输入受限的双端队列（一个端点允许插入删除，另一个端点只允许删除）；若限定双端队列从某个端点插入只能在该端点删除，即演变为两个栈底相邻接的栈；</p><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack</title>
      <link href="/2023/01/19/stack/"/>
      <url>/2023/01/19/stack/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>栈是限定仅在表尾进行插入和删除操作的线性表，又称为后进先出(last in first out)的线性表(LIFO结构)，表尾称为栈顶，表头称为栈底，不含元素则称为空栈；<br><strong>抽象数据类型</strong>:</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">InitStack(&amp;S)               &#x2F;&#x2F;构造空栈SDestoryStack(&amp;S)            &#x2F;&#x2F;销毁栈SClearStack(&amp;S)              &#x2F;&#x2F;将S清为空栈StackEmpty(S)               &#x2F;&#x2F;若S为空栈返回TRUE,否则FALSEStackLength(S)              &#x2F;&#x2F;返回栈S的元素个数，即栈的长度GetTop(S, &amp;e)               &#x2F;&#x2F;用e返回S的栈顶元素Push(&amp;S, e)                 &#x2F;&#x2F;插入元素e为新的栈顶元素Pop(&amp;S, &amp;e)                 &#x2F;&#x2F;删除S的栈顶元素，并用e返回其值StackTraverse(S, visit())   &#x2F;&#x2F;从栈顶到栈底依次对S的每个元素调用visit(),visit()失败则操作失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><h3 id="存储表示"><a href="#存储表示" class="headerlink" title="存储表示"></a>存储表示</h3><p>其中base为NULL时表示栈结构不存在，top&#x3D;&#x3D;base可作为栈空的标记;  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define STACK_INIF_SIZE 100  &#x2F;&#x2F;存储空间初始分配量#define STACKINCREMENT 10    &#x2F;&#x2F;存储空间分配增量#define OK 1#define ERROR 0typedef int SElemType;typedef int Status;typedef struct&#123;  SElemType *base;            &#x2F;&#x2F;栈不存在为NULL  SElemType *top;  int stacksize;&#125;SqStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="InitStack"><a href="#InitStack" class="headerlink" title="InitStack"></a>InitStack</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitStack(SqStack *S)&#123; &#x2F;&#x2F; 构造空栈S  S-&gt;base &#x3D; (SElemType *)malloc(STACK_INIF_SIZE * sizeof(SElemType));  if (!S-&gt;base)    return ERROR;  S-&gt;top &#x3D; S-&gt;base;  S-&gt;stacksize &#x3D; STACK_INIF_SIZE;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="GetTop"><a href="#GetTop" class="headerlink" title="GetTop"></a>GetTop</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status GetTop(SqStack S, SElemType *e)&#123; &#x2F;&#x2F; 若栈不空，用e返回S的栈顶元素  if (S.top &#x3D;&#x3D; S.base)    return ERROR;  (*e) &#x3D; *(S.top - 1);  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Push(SqStack *S, SElemType e)&#123; &#x2F;&#x2F; 插入元素e为栈顶元素  if (S-&gt;top - S-&gt;base &gt;&#x3D; S-&gt;stacksize)  &#123; &#x2F;&#x2F; 栈满，追加储存空间    S-&gt;base &#x3D; (SElemType *)realloc(S-&gt;base, (S-&gt;stacksize + STACKINCREMENT) * sizeof(SElemType));    if (!S-&gt;base)      return ERROR;    S-&gt;top &#x3D; S-&gt;base + S-&gt;stacksize;    S-&gt;stacksize +&#x3D; STACKINCREMENT;  &#125;  *S-&gt;top++ &#x3D; e;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Pop(SqStack *S, SElemType *e)&#123; &#x2F;&#x2F; 若栈不空，则删除S的栈顶元素，并用e返回其值  if (S-&gt;top &#x3D;&#x3D; S-&gt;base)    return ERROR;  (*e) &#x3D; *--S-&gt;top;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;  SqStack *S &#x3D; (SqStack *)malloc(sizeof(SqStack));  InitStack(S);  Push(S, 1);  printf(&quot;%d %d\n&quot;, *S-&gt;base, *(S-&gt;top - 1));  Push(S, 2);  printf(&quot;%d %d\n&quot;, *S-&gt;base, *(S-&gt;top - 1));  int *e &#x3D; (int *)malloc(sizeof(int));  Pop(S, e);  printf(&quot;%d %d\n&quot;, *S-&gt;base, *(S-&gt;top - 1));  printf(&quot;%d&quot;, *e);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><h3 id="存储表示-1"><a href="#存储表示-1" class="headerlink" title="存储表示"></a>存储表示</h3><p>链式存储便于多个栈共享存储空间以及提高其效率，且不存在栈满的情况，通常采用单链表实现，并规定所有操作都是在表头进行；这里没有头结点，直接指向栈顶元素，对于空栈即top &#x3D;&#x3D; base &#x3D; NULL；  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;节点typedef struct StackNode&#123;   ElemType data;  struct StackNode *next;&#125;StackNode, *LinkStackPrt;&#x2F;&#x2F;链栈typedef struct LinkStack&#123;  LinkStackPrt top;  int count;&#125;LinkStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="Push-1"><a href="#Push-1" class="headerlink" title="Push"></a>Push</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Push(LinkStack *S, ElemType e)&#123; &#x2F;&#x2F;插入新栈顶元素e  &#x2F;&#x2F;创建新节点  LinkStackPrt p &#x3D; (LinkStackPrt)malloc(sizeof(StackNode));  p-&gt;data &#x3D; e;  p-&gt;next &#x3D; S-&gt;top;  S-&gt;top &#x3D; p;  S-&gt;count++;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Pop-1"><a href="#Pop-1" class="headerlink" title="Pop"></a>Pop</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status Pop(LinkStack *S, ElemType *e)&#123;  LinkStackPrt P;  if(StackEmpty(*S))    return ERROR;  *e &#x3D; S-&gt;top-&gt;data;  p &#x3D; S-&gt;top;  S-&gt;top &#x3D; S-&gt;top-&gt;next;  free(p);  S-&gt;count--;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><h4 id="波兰式（前缀表达式）"><a href="#波兰式（前缀表达式）" class="headerlink" title="波兰式（前缀表达式）"></a>波兰式（前缀表达式）</h4><p><strong>从左向右读入表达式，如果一个操作符后面跟着两个操作数时，将计算结果作为操作数替换这个操作符和两个操作数，直至计算完成；</strong><br>such as 2 + 3 * (5 - 1)，其波兰式为 + 2 * 3 - 5 1；</p><h4 id="逆波兰式（后缀表达式）"><a href="#逆波兰式（后缀表达式）" class="headerlink" title="逆波兰式（后缀表达式）"></a>逆波兰式（后缀表达式）</h4><p>相较于波兰式，逆波兰式要更为直接，<strong>当遇到操作符时，将前面两个操作数与这个操作符进行计算，结果替换；</strong><br>如上的 2 + 3 * (5 - 1)用逆波兰式表示为 2 3 5 1 - * +;<br>这个过程很容易用栈来实现，将2, 3, 5, 1依次压入栈中，当压入 - 时，判定为操作符，Pop 5, 1,计算结果后再压入栈中，直至压入完成，栈中元素即运算结果；</p><h4 id="中缀表达式转化为逆波兰式"><a href="#中缀表达式转化为逆波兰式" class="headerlink" title="中缀表达式转化为逆波兰式"></a>中缀表达式转化为逆波兰式</h4><p>由于计算机中广泛应用后缀表达式，因此中缀表达式转为后缀表达式很有必要；<br><strong>从左向右遍历，遇到数字，输出到逆波兰式中；遇到符号，判断其与栈顶符号的优先级，是右括号或者优先级低于栈顶符号，则栈顶元素依次出栈并输出到逆波兰式中，并将当符号进栈，直至输出结束</strong></p><p>如 2 + 3 * (5 - 1)则过程如下：  </p><ul><li>2，输出到表达式中，2，栈为空；</li><li>+，到栈中，2，+；</li><li>3，输出到表达式中，2 3，+；</li><li>*，到栈中，2 3，+ *；</li><li>（，到栈中，2 3，+ * （；</li><li>5，表达式，2 3 5，+ * （；</li><li>-，栈中，2 3 5，+ * （ -；</li><li>1，表达式，2 3 5 1，+ * （ -；</li><li>），栈顶元素依次出栈并输出到表达式中，即2 3 5 1 - * +；</li></ul><h3 id="行编辑程序"><a href="#行编辑程序" class="headerlink" title="行编辑程序"></a>行编辑程序</h3><p>在栈的功能下，实现用户在终端输入出现差错时，及时更正；</p><h3 id="栈与递归的实现"><a href="#栈与递归的实现" class="headerlink" title="栈与递归的实现"></a>栈与递归的实现</h3><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear_list</title>
      <link href="/2023/01/18/linear-list/"/>
      <url>/2023/01/18/linear-list/</url>
      
        <content type="html"><![CDATA[<h1 id="Linear-list"><a href="#Linear-list" class="headerlink" title="Linear_list"></a>Linear_list</h1><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>一个线性表是n个数据元素的有限序列，线性表中的元素个数n定义为线性表的长度，n&#x3D;0时成为空表；<br>抽象数据类型：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">InitList(&amp;L)                &#x2F;&#x2F;构造空线性表LDestroyList(&amp;L)             &#x2F;&#x2F;销毁线性表LClearList(&amp;L)               &#x2F;&#x2F;将L重置为空表ListEmpty(L)                &#x2F;&#x2F;若L为空表返回TRUE，否则返回FALSEListLength(L)               &#x2F;&#x2F;返回L中数据元素个数GetElem(L, i, &amp;e)           &#x2F;&#x2F;用e返回L中第i个元素的值&#x2F;&#x2F;不常用LocateElem(L, e, compare()) &#x2F;&#x2F;返回L中第一个与e满足关系compare()的数据元素的位序，若不存在，则返回0PriorElem(L, cur_e, &amp;pre_e) &#x2F;&#x2F;用pre_e返回L中数据元素cur_e的前驱NextElem(L, cur_e, &amp;next_e) &#x2F;&#x2F;用next_e返回L中数据元素cur_e的后继ListInsert(&amp;L, i, e)        &#x2F;&#x2F;在L的第i个位置前插入新数据元素e，长度更新ListDelete(&amp;L, i, &amp;e)       &#x2F;&#x2F;删除L的第i个数据元素，并用e返回其值，长度更新ListTraverse(L, visit())    &#x2F;&#x2F;依次对L的每个数据元素调用函数visit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表示和实现"><a href="#顺序表示和实现" class="headerlink" title="顺序表示和实现"></a>顺序表示和实现</h2><h3 id="顺序表示"><a href="#顺序表示" class="headerlink" title="顺序表示"></a>顺序表示</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAXSIZE 20#define OK 1#define ERROR 0typedef struct&#123;  ElemType *elem;  int length;&#125;SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="InitList"><a href="#InitList" class="headerlink" title="InitList"></a>InitList</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList(SqList *L)&#123; &#x2F;&#x2F;构造空线性表  L-&gt;elem &#x3D; (ElemType *)malloc(MAXSIZE * sizeof(ElemType));  if(!L-&gt;elem)    return ERROR;  L-&gt;length &#x3D; 0;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ListInsert"><a href="#ListInsert" class="headerlink" title="ListInsert"></a>ListInsert</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert(SqList *L, int i, ElemType e)&#123; &#x2F;&#x2F;顺序表插入  int k;  if(i &lt; 1 || i &gt; L-&gt;length + 1)    return ERROR;  for(k &#x3D; L-&gt;length - 1; k &gt;&#x3D; i - 1; k--)    L-&gt;elem[k + 1] &#x3D; L-&gt;elem[k];  L-elem[i - 1] &#x3D; e;  L-&gt;length++;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ListDelete"><a href="#ListDelete" class="headerlink" title="ListDelete"></a>ListDelete</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete(SqList *L, int i, ElemType *e)&#123; &#x2F;&#x2F;顺序表删除  int k;  if(i &lt; 1 || i &gt; L-&gt;length)    return ERROR;  *e &#x3D; L-&gt;elem[i - 1];  if(i &lt; L-&gt;length)  &#123;    for(k &#x3D; i; k &lt; L-&gt;length; k++)      L-&gt;elem[k - 1] &#x3D; L-&gt;elem[k];  &#125;  L-&gt;length--;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链式表示和实现"><a href="#链式表示和实现" class="headerlink" title="链式表示和实现"></a>链式表示和实现</h2><h3 id="链式表示"><a href="#链式表示" class="headerlink" title="链式表示"></a>链式表示</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define OK 1#define ERROR 0typedef int Status;typedef int ElemType;&#x2F;&#x2F;节点结构体typedef struct Node&#123;  ElemType data;  struct Node *next;&#125;Node;&#x2F;&#x2F;单链表typedef struct&#123;  int length;  Node *next; &#x2F;&#x2F;头指针(不储存任何值)，指向头结点&#125;*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="InitList-1"><a href="#InitList-1" class="headerlink" title="InitList"></a>InitList</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status InitList(LinkList *L)&#123; &#x2F;&#x2F;创建单链表以及新节点  LinkList p &#x3D; (LinkList)malloc(sizeof(LinkList));  Node *q &#x3D; (Node *)malloc(sizeof(Node));   &#x2F;&#x2F;创建头结点  q-&gt;next &#x3D; NULL;  p-&gt;next &#x3D; q;  p-&gt;length &#x3D; 0;  (*L) &#x3D; p;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ListInsert-1"><a href="#ListInsert-1" class="headerlink" title="ListInsert"></a>ListInsert</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert(LinkList *L, ElemType elem. int pos)&#123; &#x2F;&#x2F;单链表插入  if(pos &lt; 1 || pos &gt; (*L)-&gt;length + 1)    return ERROR;     &#x2F;&#x2F;范围  Node *p &#x3D; (*L)-&gt;next;  for(int i &#x3D; 1; i &lt; pos; i++)    p &#x3D; p-&gt;next;  &#x2F;&#x2F;创建新节点插入  Node *q &#x3D; (Node *)malloc(sizeof(Node));  q-&gt;data &#x3D; elem;  q-&gt;next &#x3D; p-&gt;next;  p-&gt;next &#x3D; q;  (*L)-&gt;length +&#x3D; 1;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ListDelete-1"><a href="#ListDelete-1" class="headerlink" title="ListDelete"></a>ListDelete</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete(LinkList *L, ElemType *elem, int pos)&#123; &#x2F;&#x2F;单链表删除  if(pos &lt; 1 || pos &gt; (*L)-&gt;length)    return ERROR;  &#x2F;&#x2F;查找  Node *p &#x3D; (*L)-&gt;next, *q;  for(int i &#x3D; 0; i &lt; pos; i++)    p &#x3D; p-&gt;next;  &#x2F;&#x2F;删除  q &#x3D; p-&gt;next;  p-&gt;next &#x3D; q-&gt;next;  free(q);  (*L)-&gt;length -&#x3D; 1;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>表中最后一个节点的指针域指向头结点，整个链表形成一个环；</p><p>考虑此时查找最后一个节点时其时间复杂度为O(n)，可对此优化在循环链表中设立尾指针；同时这样也可简化某些操作，比如两个线性表合并时，仅需将表的表尾与另一个表的表头相接；</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>在双向链表的节点中有两个指针域，即后继与前驱；</p><pre class="line-numbers language-none"><code class="language-none">typedef struct DuLNode&#123;  ElemType data;  struct DuLNode *prior;  struct DuLNode *next;&#125;DuLNode, *DuLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现-2"><a href="#基本实现-2" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="ListInsert-2"><a href="#ListInsert-2" class="headerlink" title="ListInsert"></a>ListInsert</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert(DuLinkList *L, int i, ElemType e)&#123; &#x2F;&#x2F;插入操作  DuLNode *p, *s &#x3D; (DuLNode *)malloc(sizeof(DuLNode));  &#x2F;&#x2F;查找位置  if(!(p &#x3D; GetElemP_DuL(L, i)))    return ERROR;  s-&gt;data &#x3D; e;  &#x2F;&#x2F;更新s前驱  s-&gt;prior &#x3D; p-&gt;prior;  p-&gt;prior-&gt;next &#x3D; s;  &#x2F;&#x2F;更新s后继  s-&gt;next &#x3D; p;  p-&gt;prior &#x3D; s;  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ListDelete-2"><a href="#ListDelete-2" class="headerlink" title="ListDelete"></a>ListDelete</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete(LinkList *L, int i, ElemType *e)&#123; &#x2F;&#x2F;删除操作  DuLNode *p;  if(!(p &#x3D; GetElemP_DuL(L, i)))    return ERROR;  (*e) &#x3D; p-&gt;data;  p-&gt;prior-&gt;next &#x3D; p-&gt;next;  p-&gt;next-&gt;prior &#x3D; p-&gt;prior;  free(p);  return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>借用一维数组来描述线性链表，便于在不设“指针”类型的高级程序设计语言中使用链表结构；<br>游标指向下一个节点，在作线性表的插入和删除操作时无需移动元素，仅需修改指针；<br>其中未被使用的数组成为备用链表，插入时从其中取得，删除时回收到备用链表中；同时规定下标为0的cur为备用链表第一个节点的下标，数组最后一个元素的cur为第一个有数值的元素的下标，若链表为空，则为0；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;静态单链表存储结构#define MAXSIZE 1000  &#x2F;&#x2F;链表最大长度typedef struct&#123;  ElemType data;  int cur;  &#x2F;&#x2F;游标，为0时无指向&#125;component, SLinkList[MAXSIZE];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基本实现-3"><a href="#基本实现-3" class="headerlink" title="基本实现"></a>基本实现</h3><h4 id="InitSpace-SL"><a href="#InitSpace-SL" class="headerlink" title="InitSpace_SL"></a>InitSpace_SL</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">void InitSpace_SL(SLinkList *space)&#123; &#x2F;&#x2F; 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针  for (int i &#x3D; 0; i &lt; MAXSIZE - 1; i++)    space[i]-&gt;cur &#x3D; i + 1;  space[MAXSIZE - 1]-&gt;cur &#x3D; 0;  &#x2F;&#x2F;无指向&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LocateElem-SL"><a href="#LocateElem-SL" class="headerlink" title="LocateElem_SL"></a>LocateElem_SL</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status LocateElem_SL(SLinkList *S, ElemType e)&#123; &#x2F;&#x2F; 查找元素，返回位序  int i &#x3D; S[0]-&gt;cur;  while (i &amp;&amp; S[i]-&gt;data !&#x3D; e)    i &#x3D; S[i]-&gt;cur;  return i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Malloc-SL"><a href="#Malloc-SL" class="headerlink" title="Malloc_SL"></a>Malloc_SL</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int Malloc_SL(SLinkList space)&#123; &#x2F;&#x2F; 若备用空间链表非空，返回分配的节点下标，否则为0  int i &#x3D; space[0].cur; &#x2F;&#x2F; 每次从头结点开始  if (space[0].cur)     &#x2F;&#x2F; 可分配    space[0].cur &#x3D; space[i].cur;  return i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Free-SL"><a href="#Free-SL" class="headerlink" title="Free_SL"></a>Free_SL</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">void Free_SL(SLinkList *space, int k)&#123; &#x2F;&#x2F; 将下标为k的空闲节点回收到备用链表  space[k]-&gt;cur &#x3D; space[0]-&gt;cur;  space[0]-&gt;cur &#x3D; k;  &#x2F;&#x2F; 相当于在0与其[0].cur之间插入k&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ListInsert-3"><a href="#ListInsert-3" class="headerlink" title="ListInsert"></a>ListInsert</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListInsert(component *L, int i, ElemType e)&#123; &#x2F;&#x2F;插入操作  if(i &lt; 1 || i &gt; ListLength(L) + 1)    return ERROR;  &#x2F;&#x2F;获取空间  int k &#x3D; Malloc_SL(L);  n &#x3D; MAXSIZE - 1;  &#x2F;&#x2F;从最后一个元素开始，即头结点  if(k)  &#123;    L[k].data &#x3D; e;    for(int l &#x3D; 1; l &lt;&#x3D; i - 1; l++)      n &#x3D; L[n]-&gt;cur;        &#x2F;&#x2F;找到第i个元素前的下标    L[k]-&gt;cur &#x3D; L[n]-&gt;cur;      L[n]-&gt;cur &#x3D; k;          &#x2F;&#x2F;插入    return OK;  &#125;  return ERROR;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ListDelete-3"><a href="#ListDelete-3" class="headerlink" title="ListDelete"></a>ListDelete</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">Status ListDelete(component *L, int i)&#123;  if(i &lt; 1 || i &gt; ListLength(L) + 1)    return ERROR;  int n &#x3D; MAXSIZE - 1;  for(int j &#x3D; 1; j &lt;&#x3D; i - 1; j++)    n &#x3D; L[n].cur;           &#x2F;&#x2F;查找  j &#x3D; L[n].cur;  L[n].cur &#x3D; L[j].cur;      &#x2F;&#x2F;删除&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归尘</title>
      <link href="/2023/01/16/gui-chen/"/>
      <url>/2023/01/16/gui-chen/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6842b945ead2ffaac55e194d896965ec969942a0fa2d2dde28f4057e44ee6ff8">73980ed324fe2a044ae60a136032f20f73f066cb94ab05c7585f3ef7102865d7f7c17ba003c88a7f6c9257ae9cf3596efe20f594267075a6fb7f34cb52c232ac11e3b39701401ac666ae07b50ec54e4b5ecefd3b09016dacf711869a859892813ad32210ac5e2e1da1d9f5f8ec063db54f120b6f35dafb53a35197cc2f42878e3143f6815ca06efedf0060696cb98275d815535e3d7ef88f3e73670913558c2578d12d955ec6c4dc0eaa2d51cb649b05e8c8c01d5949d1d65a7a152be8995d88aa39a98b174a09b47ddb42b7d2fd52b3156f9abcf8d840b7cc8ad02bebbd61b1ff11867288ccadc8e05d26322a0b559dec434fa23e22a3582b1c748f21f67c5c621982b0b8cb737ac642336b8495b7885cd109bf563cd93b54c0985ab3eeedff9f17fc9b5a874a9d0f14e23fa038fccde9eeb5ef411d4053ae04f695a2b75eefa08404231a03e9ccf595433236ff586f5b3dfde89c073545e5d596f8c792f0188c56672352424b8178c602630fd2da520b10cf7d825f960dcc65258548b96840499b157acf2ceb8aa89b93e58ddfeab0ee4ec617b067780f046ddf8ba805ab3e733b961440a744be8cb07b81ee02e8aeee33ad9c16a4a5ecb009e3db628d64461e993ef51d7187c8b12b409094a9b16c77401d94facbfb467b055b726260500e5841a808d29722b9623c1f6eb09ba257729ec599195a58eb8461c55bdfd7e588c469b5183c5a88f379a133ac2e8b50543aa9a934a2eabb16c5cebd13cef791da67e278812e02fd5bef1753c33e5940e37d0b939c0b1f3ca1f6a516f6df74a7460e35f8aaca1cb6a92854d6f9b3a960c8e12064a8beedad311e4e43b01ae54ea0b0ca836dca591500a65e61d90d45a650fc5c540c9d6dda92e77639af76f98f1453c368ed34aabb5b27f7d013d2db03405302bfa27352b096a798aaabf667753be530aaa3414c719f8a1e3ba901b99d63daa8dae142cbaf4312e54675d0208c54fcd17ec39fe751ebbfd1e7b6484eee5df0ff2113543cb1595d5cfd2be8153960b01cf51aa50dab014042a87a199507d099170faa1517c6dde2308647d939cdcd8f430d34895ca1d62d1476513bd5afe9caa98ff1dc64cf9dd98bce00c4df6fde3bb08891178c88e30582ea24a763f0bc9d1bf797a294ef1f99b7242e0ab7878584312507f792b6dfd1b82766defcf4bccba983e2e64c5caa35feb327450ae5fd0e61d67a998cea3afd5b476e74be4b25cd0ba33d198ee7235143e80ffa7f85842e216d703057e8b69c281ad857345186966b58a7fd79b3879b92cc9d33daccf488c6e4425be32a492e75a251d23792cb4db7eb19a7a4c781b82db12d1beda8226b4030cce31172f660281938e5e94f6f39d26d6ad2060b5aeb4d38f96468d585c69d298ed59e2990c5868f451f7607f76c14823eb010edf3095fd89f3a11fd9669511271a839b0b8526f2ab129a6425cccf8f33c5f93f83c85e3f8fac7384bd29932a0f97bf3513767702c3ea46dcc90379a68005e5393adaaa4d40fba66b40c67c635a2e89e23aff8fd84aaf06e0a41bf28744720f7f64085a20d302ada42b85b3d10e7030dbeb51c3fc1bd9d0e01ce67c69120008ac0939ca1a3d73ea33474dbe936e5c047d43e52680a341a6463217d7dae7333b11b0c026237d7f60548c36d660c637ff97d4087d7f24c0a9dc10f58da8214801319dc04f5baea297ab95d549c7025b2f234fd55364c948d5a756eb86d4c30f4f9f1b8f19e42bdebf22182dee087082bc5894f3a303e241d01e9f5b9fc4d70f3bc3ebedd43110fcc7e2bde39aa07cb5564f46cedbf122f3b8f83f221593b4ff2cf29c2cc590fdef5fb3cc095705351d1bfd16467f7d6c51adbee0dd384c8e5a758cc5d27dc418439cce0b6b851cc1eb43412fda58bfe04bedeb7a7999e5ad1cce4b02cc272ea48061f496b2930f75456330631a93bc089d487bd06e2683fbb45af42f389a78e4bd76a653dcb62e8dea1facdb358667edd8d06abf9e8a87cd839dbb5c352e58e70b04fb7ac386a44d5730f60e250cba3e5863ff43f781e46abc47678a39223894a33a8695b3d13fad07ea1ad7626493b71364bb7a6b78132a52f42d6ca881a6d1f248667019783f397085ba93b3bd536eb6c824b6b0f5ac35c7daf82957650b520aa6fe9168fb571d87176015f7397ffb740d3d7fd72178b00464894ebc436ec2ac4ca8550d6e660ac301731d53180d524bacc96ecaeafbd70405261f8d28c0f8761d56db966d637702373c778b44dc36ced13fada2c1c6489aacc102069fd5cd91ab3260b825b53d1ed650f83ee1c0bccf246ad90c62b64399baa44cf839c34082bf41b1ec23c836a461d445df2f1073547334ed6cfb1897477535d6ef64a25c0f4ef01da4dbe2b2b2a193b272011f2d157c40b31d16b764282aa34983044c59ca7aae47d0149e8aa3cf017caeb345f51ca061914f91542cfde35b17d534158bd4f83131df063f07e4192fc045d282cc6135d3c8ac87e44465a89c0420679ee8294d01e91636ac92c69b69c004cc472fdd19c73057bb5dcbe769c5dda2c7a5c37f177b4c72eef91972723a4f48a412dbe37f722c54d527a8b0cf9fb7c278d305cebfbabab1adc5450b20e624e464b4785d46405f2d0c4dfbaba5f1851411c6b1b61bac47f6420a044225f3c778d7d4da7086bc146b7c4312bd609f6f9fa0286b96e2b0aff2a52380e2136fef1a15606d50e15763bc3c892dc936e70ad9b40b81ba6c89b1a86c81c409081dff1ca8345f5eb6efb413dfbb1b898ef9f16876001fd103ab65357fca3e7ddaf33e63f7a28f9e8ed62bf45890cd75fdc7a60fd15c68f676aeabfd2a17b2e905f4c09d0148b5711be0897c682148e2e66a3a3f8e8b76ba38d32c7198bebde63ecae14487cad0fb9d0cfdf583830ceb4b3bbf6c10c1a319c3ff9b0bf197e9831ef7760c6037ecda98e7b1324395347764305a450f77f6563fe602622d541b969373d407224811d296f82500a85e0635e8374329531e5107269c4c0939ad3c515f8f85f9fe6dee7c9d7378ccb50d2528209aa9b18f44e5ac44d8644d8d15d919a5ea1bb6735a0514e68c7f7131a7b6f7134e4d0ab0ebecfacf6835687c699ec4b2d726c4f602724823526ea645c41bb74b11c92f9f2f44e93d980ded7fd04b4e41ba9692ccbf613ae97e5c53c6ca58f14449e0a6ecb576dcba15be7c8cdd92d9185cde348792d7825af8841c29e13195bf0741b1088b6b94b9bba4579dbbafc9c239264d99404d402df84e95cd88c7bc5038623d26add8ec32029179b8dfd53f8813f8e7f6af0b75444a68b838797796bb17dbbbead9a84f16f341f206dc6f748ff0530b9676afab5db527e0be2dca21bdbcb60c9bb9b7ff272dc2ce9174cc0d9e482bca46f17f1ff49f05235d8082d27071e0ff93fac0f88c60b2fb772c2f18d4643352888a8292038bd8d40ab6f08b6c81ffc9cf146e529db33f38b83c8fe2959ec111aeec0a8acfcd8eeaf88a2c80fc89713e9bfda17a6c31691f302d17a923db2f8495cc08cbc3738a6517e931a9df9caeeab5cd8445fae0e48d89fd295aa1fa79b068abf16b0faf9840f453caa72e512a6b5769c58318aef94f30f49d9867c29a70e4fe30e51cf0bc57f12f4878ac7d25d50226a1748c243ee818ed8ac99baf1b724dcb744ef79dc58f72698f3d5389cc9ddfc0eebd4f3781f6098c27bbe3f6ecf7466f8c98831a5cca169d844ea6aa560e9bf8ad0396cc041a3ce7c29e132ebebcb2ff9309553fbb091f6e0b803ebe188cf09059dcc2a5f35db1d2e1d86b7aad40b29d8bbf48ba299e2ef9b9fa2719ee9f3e2d690dd0c1df06d386ef25f500b1b7a158e2b63f9eed8e99ce3ed958b75e2e08815919cafdd49e3214fc5fd2cc6fd2af3f32e6fa4b0ac42c0e3cc79a710469b4f8a74ee0c73e01eb61069d73a0fca844f98be5aec002e00f97764f98dcd71b3b0ecd30b1f78bf8cbb3ccb664e1c72a87cfcad030c3d971c3efdd3ca36ffad48a33e97dee72c4d56283ebcaa4dc72b1c2ca63d445441dee01d51f4d3bee50c8c485015251a7287e8455b11d78aa1838a313587da7a06f7bf42d4233f6bc7a4ef7c26247619cd04cdaaf1d6752a95ba96684a3d3314409a9efb7c914ee27f8592b34468fd6a05071f4be43f2acde3d46506947027eba765a4d76f1a097525323934d3057d92d93c55238de0fa7fd6858eb98331e12b2237e5af500bd13d7fd1a57c13b42e723051211b5bee75e4fa8c69360a47df887f396c76b72659efc497a96a72c931e7c479dfc1c9757d97a2d27a6c482497aac224a68c639e4a9232189e78b77f134f3ba32a50ac568f7decf8569a4d8753b994b146675387919871950d512b885cff2a928ef7c4f1d19a24cb8969582271eecd7f95c4c816d89cf7ee5942a2b1c619f0b0ef5d4bccdc83f7cd7d1b50360df9553392ea555219b258645167e7998cdbf8165a11b9daf0a641a05ea0353769367ebe11e9267e58223784612d74e69195e1a32ad9d53b0e58393171bf570ba517c25b1e881a17e98fd7ef9c50f3a46849ffb4df5d2fd79cc25ded115980e4da1f690013386f263556c94dcd9c3e094ebea2aedd40dfa63b9a6f95dfd0d956633d97155d7cffc06fb3fd272d598e7e488ce2b94c8dfb376dc2eabce7766b0b1be78d9cf72dd01849fccd0de84e46f513ab2ad675bc1fbe0136ab50da375334e878f41228cbc2701917e9674d4c391a49a605c9229d0db7a18d7311fafaefecf06efcc33ccd5e440b19cce7a1a7edbcd03a5989dcfcfd68341e44adf5b438ac154e49dbc8042672a201e71d3066057d24ab94ee267bfd1d5d6a914176de13cd121177511d4fa2fe4935bce9c1b133fa70437af1a6a0c2f0613e69c46c0dcdbdda3828f9630e97e59e24f07cdada241aa05bad96923cbdbb4c10b85944a0580ae377d66c0630462869a38c9a3f5e663a2f374d4b3b840e46034e869c51364533662806a29377e12a4d45926cad2158c992fac42ecb9ec885823b6f41dba3fa1bd75fe6c64b02a190ad70625dac2f414243635245a647da5a16277f45cb0150e8f7d652ea8f83d4baaf0920f204b2ca6735ed179ddb90e8741901b5a89a8f8314b41ca4f0a019e9c184e38eb8bcfdccaceede77d9b5582127e3f17ef7ea7f85af8895864175fb0099f2fa15b834660d047a7051ff18786b828a8e50570350ab815790709ac1e2cb62eaa5e0c00ceb0f5ebbed2f79a4d34a2bc33b2585fdedc5b300b960264471f2933b28b1cf82d77ed02ee163ad414b3d738de314f435a5619eb5649b46689916f4ad76d7a024e530e74a2105ccb177e8e7cd1ec77c3af43eee3299ce375fefdd4991aa67c79d598bbd15dbf867787080ed4598cf037d721910f7cba4084d9f02f5887546f4f0e29cc5dd0a201a60abe7459129a7b8fb83620a8c19258aec6ba42323ea378528e158eb28ebc9f596534d2003158d6ff5dfd60f1eaadcff2594c35a4823c27da0b27b77297562d45c674205979971774b8ac816623930571bdb550c9f0f490f7df52e94ffe445e874cbd8662a7a6406c1bc1a3a3563fc53b316739fa348266ae17a7b4f4621c0345a5b3975dc0375cf009457c69427f1520e7a13d01846799133f20343188bc7da1d05fdac6afdaaad9f94809845f8a388aede7090d9d467253af22e1fbd9efd4d95c69399eaf3069df55d9c57384ae543ec7556616fb456922daa9852102cde6d7cccbc80be555b382ebc7cec7a766a323604a5d24e0f839ae73b6de7a5548c3792cc0bc47b4de0add8d8f8f79674e0b5ade4d2675d20c0ca0d71563019f26ab22e5a72ff6a6946de92491ad134ba7c10c92126bc7689f74442b7eee4e587f81f1872b749fbe2882b53be944affc65a4555b33390b7c07a1e0097357c60f98b8a52bdce561c7bd1ae91498ec45bbf6e9e31830e2b4728ed23d08b789d84b121e8ba7fcaa7f2f4d7d5f09d23d50ea7785de2cbe87e8b199cb6422c47ca6923e90ec4b2c66853379a73ccfdadd64aaa907baba0dc7af6252ff2b943e9b945e9ded4b43b1deb1d7336c947c449c7f6269357b3ea12f01c193a591e546b1c5012e6b6e903e6ed89395a72b58d677edf1207ddb36ff0c29b07cb5095911c0b0b3c7d769b5a2aa4d3aba70a1fc74ae4ca2bd5a0ea3a43c54f65ad7f41feb4272b46b214b878ce2cefe2ded9a83cc2766779ab17e9c40fbe10c1e3b68ec67c598163acc4803fc58e29f4441ca5ab3b9f1023b136a9cb174646c6899cc560f2b08cf00f9fdd43b4bc3a1a5e02585d2aac3593bf5816e18510fab1dd6c31dd6e55ee1ce99483d3733bb09759ec7b3044df685db5e7eb2e73e75db792570589821b78cc7a656dd29a7ae7e831565148ca155a26c72f2065bd913a0690ec4aac2aa554d603a35caca89c92003ff045d7d97b2b18b54ca88a5af0ed045f6d5d8e7221aee0916c5715591ed3654b5807c0b2a5cd3fd3c7cd98bd59c01f794415e7606344f62c0c8a739ed2ea1d272b10983b746399e4e16b05f0c9a0b680fad46fe85e4761948d5bad67e98b027f0aaeb2db31a86a0e3d32c267c40e3de7012648f22e663c3bceb84f2df8fda4d4fa61480534b4c49d7792c6145a140908f5b5beff3db5113adf7bacd4b0076382d8341239cfeec3614181894aea929d05ae490720e9812ff7ce53c2f091294107986b01cc3c4e787543b3ad8c6c84acd03346df652a7f1a9c24e6e89a200a361af0639e70a6a79f3ee85df6a59fdd7cdbbfee676cc8f59052004d955e39b97e3c44388b677b23e818b69e0b5de3c3f6cc7cc70a2e04970a4fea620be53780d94ddfa4bd1ba3d00f8708e20b77aac827df3a6fd2b309e59287479e8b6af8079236be81d205b6ce3b21734c456be886fdb25e20e271988f60936d71d45a8671c885b945a88d299ef79e835615d836d4bbc00ae218bbfc6313540e2d495fced2c990f20e353a270e1d0e6b1883931fc90caf81c33d96e53d01a269bd4b266da7278c0711084b86f97b7607981ac2c6714f2041c23c4d94c1746f26ea3458831ab179c1277a568832843ef5b3a9e6ca507a0e07bf298c1aa92da96c78d9032b02ebed8fcbbc97d373e73f97b7820d0391e30aa8f84d0e911dc10c6d89243b6883b8970721249f585c7215919c3ac9afab02cab803bc56aa1027b5eb4d6e33e77396e4f2b1242931f3d5c5b9a286a1194962d608035c9a91cb172b9517820afe7b4be0d4a42e45b5964de4f4eb4368a30f6b06e690fae616b3d87b7598c579c0edcb57fd01cf335c25294bc681cc1e1938b1c33fbbaaa5c7ba01cca8c50e3e5a79d6471c39e62412980d7369b94ccaddb7c0f42a42f9660486913ef0fa2a1820ac5640f12cc497b23099646b60ec4c2c12c9cbaf147c759007b4d14879ef76c66d3ff9a77a14929ddf087c24d1a0464cc7e206526c732fa5e35880afcf5f0a1c717adad741d827287ffe19ef5937c60cefda86992fe8c5b36d9775affbded57c5b9abd485eca01c9aba998b7d4a80fe44e5e4ed310a9a5ba0792852724c25414dc2962252732c80736d41cdf813e39b134c1ba596405684136e01f19f351ffc89f82a18be85b6c1b5d48497a2d06d8bec11197a4feff89a4ed22ebbf8980d742446c199167fc72249b8e75768f932cba5d48c32eb935b94e4dcce3351a987211d324218cede751efe6e6c65380a0589bd645eacf4826e0a51745e38cf0e2528b0e76f47f28e678fb1b3892bb99735a79e46fe866ef4f32507b52c1f44d75e2bf33e4b9440ee35257f03e08a6c8ea735ffbbf46b363c5a9440aacdedf7b558bf9a5d640db9adfe1e0a1adeadaa9eb0ab84924c5c4da57fad6e3170a038dc97340443c4336be5a04844b4b7d421bffb6ba9149ef3d69266895fa7b0825f27666b4124b8f203ac4460eb97df1650ea2da3b86d2fbe860ecc9325e3150c9c11d0e752196a22180b021a4f5f61dfd4a17d23224684bcdb8d4486f24020bb93de248e3aab99fd7e99c31050d2532d7fa4171152725cf762af9b2be215676cd5055124347bdeed3c6bce901948d3a977628d4864bf0a114b45eb13b260067fe4c6e0e0b4c130f73133b319498fdebfaa57ee463aedbc1c512dadaad3f7213aa4e39ea7ba66d18cc38877fe0cbf6ef5512474d24800a078b9b38522f5e2e51c8b9839502e4808b8af58256be428d07e98fb1a0e1cd29265896907ebf05ec3c834f04bdd643bc6c51913ac0915d69a4c58275bc9972b59c0da3576ca2d4e8e8f640934a864f44bb570665e1b70a0a78af191ac9618e72c089a85186b39d92587a3f0132c72e77580f5e46c5c73a56d304cc9cc7269a4cc42aa793ffbbc90e78dc82c2f8e978c820b0689c0e6054456730caa75c3cb4221e4675118cb4d38e733293ac1d35d55e6642c3bf7a847e57f939e7d5023ce8f7e7c67bcfac4f18484c61bc8441ff17bcc9540fcdcf9366fdbc2beb4aee2d4d229c013ed6ae21dcec73ee4480dd86968b97021e1124476d8701a1d05bdc9418bf0bc75b705f0640baea970a40591dbcbe56005e5df8bd8f6b5f45e4f5f46461e7f9e0d80a6ad0b54dec0347016ca3b5bed3f722dcd43e7fe90b12b0fcecbb2800ee20565e06367a3acb82c27d734056bd215ebc4aa7bc42735266c89ccf3fc42f32e4c91298ef28a129454db8d8044db94615b75291e8a4fece78254c2db5e9b314b89881057f5b950f164f2a9b7a9eddb6b7d64a342e5892e63a85bf7cb65a710179a128663e5d2af275b99d8e87f51b747f32fb4a731baf989a30f7c246ede75b0dd986f64679898c133b739318b55c55fa4737bcbc68bb2d1a96e66e93094ca4f1fc0a8dbc6777fa64b7e28ef7e1f98fc2e41680bab127516033869243cf01313e472ffb083f58e5f7bd177abf257d66ea32fbfe9465366842b419d5947708c1a568274ca63556f5803c4fce14bfefc70fa23e16f86ea9052023e05152fa097acfbc5051b8259b288c1a8c2caf4a113ca32abcb849709ed441c89a704151ffed09e9e5dbdca0e37c6df5ce05543665b3ce675937bb8a7c3be0606391d11398678f05dee51150abda66a4a81eb9aa03eb69391d0d3921d94574f0d918a50fdec557839ec5e47ab8d63bb17de4240a33e49c86044fb6e5e148e98887a9e71210a5d0eac0121ba83b4abc04f40d115c86037aac9d6e77ef94f8d03ab25d2fb8644d65a3fab073ace393fce13c42833790fef4c8a4fa692e957c9186ddb68ea79563a567dd4bf63e3257ba5e9514c9d7d094633264dbb84f89f467037ab83c3c1357106e630f0bed01df7f942eb68beb422e9a6dcdd79f54721848c71d162f7b87282a71ee27964e8862d9baa0a6f94331f0934e0ae83de2ee7a9bd9750ef0f0b364b65e45db14d1f69087ad382fcf41658e90f3d873a7546ca052358aa5021e37b3ec39cb55ff85a66e0daf6db07a14389c8b96ae2f3b858dbf2066fb64b10ee78d0dba845ed8416036bfb6b312d3ad480b69c7c54b1e5376944decfbf2d78b7207a62a628828e6f4a078428065df3f2f855060582f9ebc1f7b2be4be894b180fbd69c23f465f60db64469a4813748306520277e5f2ea435a52b6de4e73d8140979f52ae118793c99a244da2e1e791a03ab6f6859b632c1a8e5baadda7b1e6b4457d6e0f4436e7f74e0d7307f6bdfe1c65781e94bc8131c1c00033b6b5b7317b38b6bffd629a196ccb935be5ac4567d1640d797f3c978ba1df55922d96e8f41213e2b8bfeb8566b8069d82bc3cf7136b51e7852089720cc6c76a4fb606102da9a8d2ff6acb2aea562b92bcd956345ed4d330eeb1b9675f122db50caccf4057875701f4169dedb62e83dc1a99ef7da9724fade38b87ea661f662012400a36c8b931e5976d675aa537ee8a1226a56026e942e5e6cb61283aa176222cb33ed934ada6ea637fd546126beaa8792aba0acaa090ef4ba490ff0d695c495d7f728be366116ebb8585b4566ecfef83cee96ec5c1d5355bdc294a40b35a061a1fc39e39e3d81e47f8cf1dfcdd04d0affa873eb97d3ffe01d10e0e1e614c0b0975f482a3a7933647782519ca1f398e058969421f6344d7fc878fbbfa21f1aef4387fe2a852e2acd0001c5fb70b277ab85d9b893168e88e4747c72e2831792c3d3fa0db272eae6491bb8f8f8efa2dee6662aef6847f06ce2ee8135d09e4a8debbce5377048715a1af3da3a1a011bd8d66d2b52337d6c13ce7307cf5e6bbdfa4949cfd949e18081f76464079ebe81ea42b590f11df7ced29831315c2b3c7cf58a13e072611757f2fa90d2cbd14358f462f1a88c586399e0928f227b3f88fb89d83c082ab84a2c98674baaabc1ca9f8f9dde4889f89757d7a6093f810ace7d7b61fa50e0d9e2f0293b713442c3d8cad97d04ea787bcdee956d842b5b7570dfd1d70025560eff46b03da535e20bf15b1dfe4a4b56d1d3c47447b8837ce8c5994e3d5471ad495acfd31984ed6fb109cda793e823631ab3c1f6e3baccee92f47894b197224ff966a6a40d538cea09be750710ef14c62c3d79615b20ff16ddde0acf6fd9a86336cd89f0db4c2d25849721bd65e25c6f573e4cb343c3c8eaafae899d87bdfb0621769d448cc85ef42e6cf52f55adef116991cae918b194f94160b3311ea13a2c70d2b4365b82bf6e96dc2d83cb1286ca3e9d9d7e661c123983049ceac0b10f7799a3756d084ccbeae8b82dcf9d558bceca7e82cf07c6ec739bb732abf06ed506b1566ee55cf43a66ad2d40be23f3a2ed49b535af01b1f1fba1b85d511f44b46854d6a1aac5bddd8a7310e0584be1a5df6104229377fbdce4781fd1d857a69fb789e7438346674d8776198f03bbb7b431b1e3098d5c2d847f97e320dde41048c64096d2335a285f23866fb629641c053e4a4fd10e47fb778c344490edd5609deabb23380271e3aa3586eb725d11fa153b81669254f4eee05c8d68dfaa9da6c315c60ecb16fb0ec7f8039289f03d6de3b1088a8e5d4d7022eec6b9fc3689459d65262a6e04f3f5d984ce2b0b32ab0e1a9fb6dc2f5487aee1b001ffd77e6f50ac126983c229ca71499c5da7e11eaa7c36138461e9469a98748ca57a05bb27459d75b89a0d8df79e52c991cd71b94d3e221b5f0ee71af5326ab6aa67f36b35ab40328b6720af70f26d5074e3b95c91547aa2dd2e6c098d54f032e8e50d6d987a4339ee349fb75b894abdef056091990a4fbb1646f42cae5ab676f717e331d4e2d6a2ffb63eee4b5da04f9e2d756f168662e8978cf9d88a0792714fd8f7aade1640012c3cbb1b205e658b1cdae917a8b18d7b0b62eacf321f522de9eb425c257a83d8a62a2266d98c8b2f4247725302658d4c3cc673878c9c808707e41a6ed2cf454f124f15fac50d43e4fabdfc87d28301951ef74404ff39295f4f7dca3a2f42319cf15720d21b95a7628a83de3fabd36b6c00819a71b5729c3d5b1e809d3679775f131f2795e9dcb5f27e748d747a26d6c5af219f30a11c8140c95b92b558acb3e02e0357083f6c12c4c22ae51b21639a7de743a191f12ed2c32ce144effd7d5af0c9c7703e8255f95b8e1a1e9f6c35c02d5d981b999746941268ee27171bee2bdfc0ac29b75de4490b083d5f128b91b8d5a21ec22c03252949fbe35b0c20d760cdc8927943e9d2a15a2fad7ba32941717c8f75f9127890d8a52079099e60520d9c6d3a9b6d8fbabbf601aed7e7be35a4aca096fee17278945d80bd31264b35b5f04b72a8f3e4f6ef1186f87cf567a26aa2c4f87f7dd63a4261f20d96a2f066b17698ba10980fa8d91c87ceae4d7285f1abedf0a09ae24d3896b85b9be8bdb914d98002b22a5586135a834e47f204f7eddc26a685c3c71bc8421e6b86341041679e0bb70d5fc044fa0af67d1e63835497175fb8aba04d1ff1b33b959393ac06808e0a6a59bf73e8457a022c2bce2b9e59ac0b8db3edb8b95f004c2bbf7fb6158ec3e8e8b854318c2af005984ff5c2e11e91b72d717dfdbfabadb3e0dcc821e96c043fdf8b0fdcf298f807652cb2b8241ede5eb5ec9e1f9e2813d5201342b93f244006da2c236a50764172cb52c93129e9349902d1a114c4105b2d3dbd94cf5336da1a965d6632da098da9ac2adb153de87802f6c4f6aab38c977a71718db38e77417f3d850d20f23faa87635c82b2d4a5d6e2dddf18dd9daad732be16a37b02fe730fdc2f5d284f9dfe1102356ad56eb170cf83b446e9d434ff81becdd9ff21dccc0d6a0fd4eeed558bd6eb0adf17a02f068471951ac9fee2f7b6ef9b4ed22622f06fb7795a6d9f8dd737fbb2c102ab197688c00378d2f6b5b9624d553510f1da1147de485b0aa14ebf12f9d88d4ed7fddb11bf9482c12970eeffed97dfdb36ad85f178aa600b1497bc6910d66ef16356d6eed7ed3c30de3ca66a12674086057861ae4b899251426b12463b17e8e1f757f950073d416ee6ea53bc3cd70c86254ee63a6e383717caa377ea884a3f6d039f91f1eb50f50ba585277b61770aa3fe35511fbcf7c007925b913536e93cd1729f23c98708b74c86f7ef4de8c2079d36d340aac1e6c0c516079186fd4b35205ad9e91bbf0673f41476d31076d245bf51bf2dd1829d4bcd36d6a717fe2870d5613a3b43601a44a84621da72388a23270cb1156439870a68661bb858f284eb021c9619c254ca0fcdbaee6519aed87177de0ae9c5674b1a024c636fe63daa70800cff760866a65c7d1f0d99b0582bfda5dba64a5ac95de59d9379af0337d5b455c83fb68f46f4dacb877c4758a9744f03a011c47a5c6b5a45c5cad08a95a9f9c4946d329b66b6a3bdb5d801269cbdb11143c5b2dbf3a35214d6965da6c0d5819134c54ec6eafd68987d5e0ee5e02a6c9a3659c9d9affefff198e783845ac46946c8bc7794f17a23bcd2c064b6ff6285ec9cbbec929910f6bc3c727bf6ab2bf0c6a9c9c871058cf4a262571f4a502b89b132065551633bfb884f709d5f4a165e7113d2cc88897257744964a2a8fc88b626001ec46f1a6ba5c511d6dc4f206b6a43b0dc8edbd9dcb7eb7ec46662f4568333dae175454cc7c9d2302d0bc2ee8ed97bcdb356456c92de4ad3fd93c15430f980cb0b8c619ca6fa7a8b0ab89689b1bf3a511fdec515dbd5901fbdcad83752b55f6ba4b52cad8518074b16c9a9d91e9df569b9ed5d6239453f0d9221325222352bffb9bf70a5a127dbe7a4a51600272f6fc55900950311ac9baddeb9b9ec252e1839f0efd3e3049cdb363510844935d127b0f251fedd3c88089a973588651a0853851dfe0451438e37bd86a99ba8ce9b25e322475f5f5629193f963f2f3cc2190c47caad39289627ea7e5899919bc8d84b31d2a739e6e3841f76442dab94281f62f7174213b8d34a2b95a4fbeeb25ff131f30f0b32b078ce5393659420edd6ee0a5b04cb3aff83792bb9defb9b0f952b71ec02daff98f3f57e3ae924f6d3df7fa0ba73a195c58669acea244450afe540c128d767afe144a139f977a3c4c0f9135ef72287735ff00af67484ee2a964069217135ffc32fe2e33680c638d4eea4fca84388625ae68cedb402595d513f38661a4fa8b86bd1dc7587f267df041347344956f1d9c79fdb5806e07eff1af95a454fc7cbcd77423c12e671ee3925dedc03fa30436f97cb04ec54b6fde02981d148958eb6bba7203ae7f4cb14018af28c156008b44b7ed95f33fa9e5b27fb4b4c5beb240ef5999d3eab0c80f49299e6023d700e959d5f77e8fdd591e3b9b151b24ffddd8df9b603cab5de3473852c77e94df36016a668c06952a757288f72bfdad16555bb5c64bd38d6bbe3409eedbb80d228c3b77b7b0688e947af96b5d123cd8825a57a9160e9a87b819b858e7fbfa9fd1177a894b271d1669afdccd3eecc677633d7e9336da3c2e25c0f84900ee04479aab27d91ef26a68ea3849b0af8cde25494f2b91304727a0866b5fd366646f03a42b6aae871dc72fbad1ed7a0b45e067a7e03dd97c2e302a35cd29fc71d8eb90b460f2e8007dd5f31c33410822607fddfebe630a05461b6fe9bdaef91db4bd483f4e2da749e4530458ed8473b3dc8648f712c8c6326e483304f6e8b2a86c8052927d86c8f1e0e8c7502f1c91b7500f7a2751bfed708e004e2460b0ac4b42adb97a925121593721319562d70d8c76ac4a6d08a385c8e562e473e1cad9b6f82793720bd2628cfb7c33fecaab2ec155d72c53dd140ef6e27f286ab080095a70e58eaa712c891d10ed8cdfa26f757facdc313e8b1e11b64c95671094584091f58a34307edc57f563628bdc3537d1ea67206506677955b8d05bb762d7ff1cc218ce5ea2f8bbf4ce0fd180bd967bb7da2d3219b8562721f7ce155788b6bbd0067f2c4e215822ca927053b7a069a63a19b565450c338cbe7d86441c7efc8cd595a5d11c8bca7d95a87df4425f0d3150f36ab57c43daa3784bdd221e906ac285dc996de61541299f5d09354e88f66d53ed58c72f429190bd59810e30bbd24e1e76c9c34973e71847a369c930d6e2961fb13b8fe7f7e048e9eaf4d24f45e30bbdea8a1006668d8da4e61eb10c1c93a6bd212f0d5e694361094db4e618ecdec89c8c6671ebd962e51748e89296c8ea3798aa16d6ec2b5557dbf7eef809891cce759f2d21001a45d11bb6450fee9ffc327c53370a569afe4a1b3d36cda9b92a02010fcf59c4890f89621afcd331f42bd0665c906a04b25a856185c7c47d47145a0d34f307eb253c116944a69f12757f7c42e659f1f410ae8ec39ee3c6c9b34cfb6c91e9d1d999edc3dd1c37ec80c2dee9208d506f6b407910c4a1a24e8819e55b5ef18b2ee718b8c464255277d0283aa1b0713ac2c610de7c2089aa338bab4cfe263fe843b85c794db5d3b611cf2ca4237dd78e18f0521de2ec7857f204ffe74abb2cfd704ab884e9dbaf4a84394d0a97824ed3eb0ccf249a7a532f73326df73d2cf6b58599d0e57dcf2da4ddcb8eb0308508916f3dd5c145de3d986b52bee5b42c0d24b9d7fad2cb0800621eb954239b18b9acc219e2541c6ab26c82b4dd03b83fd0daba709ea45514d6a343efb20a548db433d89668cf6a40bff8829a4cf0cbbde7dac15965faf6417f13e81f90bbfcde83e7ea7dddef46fb27281b8629e192ae9074d12b53f9f99e3c8827d4ee9469de13b71f260b864535e0feea84d949df6da991379b6368ee2a806727f586ec23d5872863c4311509ed903cf16a35340350f4f109221bfb733b8ca86686a86d3a2ac117c591fcd64ebd176ea2189f560593b618f38c225c5dd2053bde0aec9bedf3f03f8b8e4db0ec26396524f59bd2ddceb2e5e00cdeb3a8450cad561460f5b2e72839eb20e494c62b366946823585aac59fc01647f2cb403ec18cd19afa773bb49c7d9d031eb42c5b8ec3e3f73fca7841691bcc6c66eabe759b77e1039e90147a04b40d91510adc266a2df662719889b19716e6e0c9cee76bd10c480658b6e2529c1a46f5855578ce69b684b467cd1cec24951a42f17ae7cb5a2ed2a2b9e6fc4054ae4aa86963ac7eda6e9579d8297a7a628139f7bcc1ef56058433d2b7a609e9c9932827887b0d93bfc7eca2dc7aea942023ffeff8c8802975f9643215413733df69f1f903f8fe7d52b46f66516ae0e4ab2c5a877b01f9ac1befb0bd1049728a4b274a2a1ad3fe90bb97e247073523c99b6062d88241223dff0b2c62fe5a29f582f24b79868e585581496e0ddc32908e46f298654ba189db6f030813eeb1e6a83ccdec9be07417aeaaaabe35af94f5007f49626a5220eeefee4992bf9e01b4b66c8e60e8b332293055f9059cb1e86713d59cc88c26ed5c6e777bd74aa7635345e198309e2b3545bf072bc236cb8be7c7d68e510967ce68febb37cef69de0ebddfb114d02ade8e28ed72507ea27a17b8ec707ed215648e39e8fbe48651b61dfb204c9333f27acf92485a68d94f851705b3587c9e3190cf69990c0a2e2d7b62a1705ec06cddd2ee130eb883de4a854e45e7b48613b8eee579dda372e8c21872e091a6bcc9668af5b95592c66bb262bac5ea57b38e2e23c8e4b8bc6bf05b2d0bfcd500ff45112ae965c679a2fd8eed7aa09b5712d2edc7ab13c83fb2d92ac8114c3bbb24471642799b7530afe8c75e98342dd1bae2b6b65a113ac375898afbcc37c6c51a035f056b5261afa39874a43956c11f8f3fa7a07ac1a62c54596edeeffaafaf2eeb96e317ed21e7ff09213a51697fa6473d1fccf9837ee76e07320a6a1c0f4e39a5aaeb435ec9e22568bbce29460d641b4d5f16ea0a11285fc1c6931230ac6936960fa4ef5cd4e6f8e2392eaa9d7c44f13ecb674d0dc6109d1ab30bdeb70d7f60a4fc0f47ba517bdb67c1b33d03dbaf7526ebf0ee8d3fc47e51129a8272e657f2652c297f154bdeebb605e052e555cde258e6852d201915305ae7300f127a574b8a6d5a6569dff0149f3b9e9372c08538c0c8c809f601dbb54ac5b9c3bbd7e1fe7a1426fed68d993ea642ad0443b9403bc3c93ab263c5eb1a696975d15648e81027bdb68a0c858d4f791acee13e8e2722416e34d6f89a20da33ec900f60fb71c7cc26d086c501305d548e030c234d134001d7a7c32d0f11d64f89ad8dab7f2368fb454ed8dc4e0b39927089bc3fe316a7cd49d4ea2e23a6bc039a9d0e64459916159a80df63556eccc0301f58d39d1bd41e773559dfaec6ef10466cac423116c797c79b2903b59431feae04ee79db878cd22bff811aa4f67546702f7ae7fa96daa8ce1cc63a96477165f57d47ebe334ac6162259ec352d661fd6e077b0337898f66a830ae4a485df86f1655952c2aafc34023755b62a65a87162f352c452173ef46afdcc68abea3ddb1a7d422c6d5a4b36f2139dc292ed25e7edefc1d481d3bd90785b7ea0b0569d9c243839ac3b6c920128a0a269de5db5456a8598dbce30f36905565d4db955bf636eaea042ae48fe7d4a2810ec09a796c86dfdf40da09ca88a6efe707ceadc6d6d500dd14a8424333281db0bbce6deca547ccf51aee59e57c592a3e910e1feb7e00face4986d0b653e4389bf0d048b62cdf1617e5861b11b25f9ef6ecdec7621dc5779fdc723aff39713d4c26862b8343f668c80dd1dfad4dca02a7d0414863dc4131b618c1d03a4ce32844d0a311df32ba4e985696c8b2eeb54f49158e5cd15964ff3d3acd907c7b48c9c00fb8348df470030ac190e3e7f2abde8328232b349fd890c84c9cb134cd1efbce541076cfd887195105157bfa199556ccec486e05dedbc16a4adfe19fabf391ef0cfdc963bdb60b573108a3ab2a699583b2d754226c3b433776a076681df864bfe613db3119737d2f12f3d5a22b86c8b35eea0bd97468bb0ca72eb2ee63846c4ae3621dd412720796d0cc5ee91cfc5345da10f789f56fcacd73419bd2e4fb03e031bfbdbde86790dc89e63a5f534375de3d47020e01d7cf257beac2b886c40ef2a76c49f7f4b5f2b35a888a7d633ed015febcf679e13bb5e79c948cc7dcd5d30c5d9d8cf021df2714f8dce47417bfdc0ff2545448fe5a83d01f2e6f0862892246ced18d870a6daf35547ce334c919a3fb54fc4fa121345510504e359b072159c28a782a2b34f0bf5cd5d75a026421c92d8f93719e9b33daeaf5790eed3082ffe6b7d65bfe06eaa2c1fc678dd535ff3d87a3e3baac0721c101f4bc34cac935c0cba48aa41a0466a18b4e19e31e8dd9641ba79787bf21f409bd8f75bb43e99d6b5c662792abf44f3918ce5c0cea727cc70f0f761f195417c7b33385d468dfbbb4b6ed7b64e0e0444111b51648c8cb11ab24a6bd9a2a56aa6c510f9df6dad9351e875aa1340d27181a663892f520cc758bae98474f17f29f3c4fe81e1a8b265d0150a430c8729b579304a219a4cc1df5996b3af22eedf107863258a4bd3118b5db185ecc2feb32cab1a7e0dd09b98850ab80fd5362cb8c336ee7c52338a272f743c3761a52b2c8436b9b3eaa36540cc6d239b3a7340364b7d3e111bb67c8b031038982e623cd994dbd95fb03915a180901c7f806f4919b0b060ada909aa7c4933d7fe15e75aae4012e7c0c3b140aef8191418d911cc5816de887e159742409bb355d7fc9a3ac8659900173ccb9feadfc329703181fcf6edb1f0d26148e1dd43477669bd8376b0bd9cc52b85ebfc32af798596b9ebb32c6753b2340ff60624aa1b69857d8d4f799fbfb5ea05bdc3220533e7ba24edb18987f66d3e48599d1265960694a13ed3e902d23b90a4b05eb468e9898abb0a22d385668d9e20ddf0b930caa136752db7dddbc30cf1aaec03643e57a780c4d909e6a88c25bca5753854427707a3bcc8df579db3100a4886aa0ec84d70d914bc187487280053034599fe170196f0e2f08f69bf7ced2e7cbf2e88846570ba7324ccf1a9b177eafe443c38a7e97ba90f54bf46bfb90f3c011d5b5c2b4710ee9a8e02b8644df66a2e8ec39d47caa7493fe8b5ce689050e94e7fe9daf4d1f9a9f00dedaa3eabe2f61a8d10856252ab3a1586b3e05676aca003fc71570f6db947acb0af4386f35f042011f8cf30fc32a2285a6fa0157bbeded14d6c05c963f631b086d8a8d5abaf807473ba0673ab0ca00fcc2d7e5c786cbc1a27389b2508fa19dc1139ae74f1829c7acc02cc2477ce70b6db813282ce51195956ecae4c06a9468e34d0b9ff5e198573a24a94a77cfa098083a51db36e834899dfef3db9aa57d1c17a01dc7bfee2d4c01f261c7b3d497f4241295e41dbe289c8e7af93dbecc66e79f9f8d2a8e68ee51f610aec84a3117461e45325b7ab35e92057d756af4b25e8c30b03ff7abf38fe797e5868a15ec7dab03b780f41037fcf84b2d2116ee89381c239eb57a03a4f7215922002482446736970255095741d9297605c445d20b265506a82a767202e555f712c8336e4c5c7b57b54db34f3d89d01c95f953a7ed2d02a3e54758a92ef3b952722cc33d0c865d8c804cec5be588d565f68d737aad8fa0f322f392b8f6f161703bf8a987a487cd609086a0f413f280d35e050e5e2d5ecf8f80d7a5c5b319dbae3d65c2818d38ebda01dcc2613108771a92a2a90e9e214cce82c5077c0c1ed3eab8a8aad51e2c7328728280ba9a6020899ce0079687a0d88fa230c227193cb6567afc7cff1d3684df165540a0804f327ec8fc6eabb9e0d9edd24cd7ef189e27f58f60b1825f7620720c41194b39883b5913e7bb26176d7ecee171ad685c78c155302feb02e65963e344e9cee140f41c00b35c9bcf6c2cbbaa797f0b036d152f28c7b9085dfc0c35f9033ff374551ab15149be8ddadbbbe31a377b3c2148c77321be1052e9ab4954d508571bb922630f5ff9befd743dada2bfb513fc8d0236e499176078fa0d43f8d6ba7e39f461bbde2640911602d6f995e537308312344874d343f77cbc0993efe19703e3160f16d749f055b08b3bd24748e63abc2cb13c4d795f70f04c3fe10437e8c0eb0a2b55c953bf964ffea6743c49aedfe7cccde95d2b89932a1d2126ba2da2f8bf7ba5aedaec4b86e0f257eb1d835a28f4d41ca403c65bb5d6f31aafd04dfabc3acb711230e946caca0c6cd6248eeb238f313e47877216f7f89344885938f6e078f39b50a66487b6e59dbe200a27d1c3c0c31ca340bbb7a7663c81dcf4b0aca6335ebfae45d72a6547820a0bf7d2cbc89118201350dc7e57fc6e1577d36595730c09a0a0e4dc61a9f5bf6d19c41d7f18c7b690babfa7f4d120e15db2ac52696f2e9c4b448f36a0e654ad69346af8662b0271ff381826a0a8c8bd36a4bc14a64779435ec804b1f5179a5faddd2eb3df5bf7e37db26d4e8510d403a5ea4f2021f695308559440240e861e097b3433390e4303301ecdbda9ed76909d5558b7d32344ff23a3bf8ff3ee6276a249eb0b4b75b3c197440b9dbd7f4c68f508923786a93b7092a71b426fb82aa6bec75aaba5a74d490248b47cc8deca47b82f3655b53119f8bc7a526bbf3a3d89a8eb37f17dad367ba4407cc08f0baeb7ed5baa24e9be29e7ea9be3922d633794e58320a770970188e988746a24e4a82bb8d80c2e8b5c19a835b3379509d2f06a6a8ead4ae238dfdf799f9daabd9805560e4951e19b4b35f5012a1edcfe270bfcb1d053741914180b6628460abe680f29393ba5c80fd24303328369014d00c44d20139b4bf658b72ddedfd535433626554684bf6513804cc842535eec7c1eb8508b75a1e5a9894e27d3341f764a39c8e51c72794d07b99503c60c497e78fdb21e645c7cdea81c94ad7ec0866c39fb1bea608cf4c8022f6517ba454b2643fdf88b45831ac54a646033d3a136415efd210c140d47e37698842387fc546b6e2ea36b892d4cdc8493f8fca057cb71a5ee32613114615104ab49e174971dc98b430f7aafceff0e1cc5e68c2987b144315542be6c80605ed81cce6e2345ec400e756baebe2ae6c480553b28eff471601ef8c700fefafd123d9dbf678d82b738522c0252b7b6a60f797c75d2dc3677d919e4d2f6bed176b9f9cddb7fab47e74e97584464cd6409f0413bdbae1dfa02310eb1dabea5fe77509f217522dbba544382451d603cc928790042928f666c920046db85dcc1b696f04899d9468da17904a9c89d554a185859683952fa670618b9388cddc0c876e6747ac5c10b30aa4a3eae1953c0cb73e26e0b6e290d7015d633e80f683f45626d58fca8f3ab3df80c7f1e457ebf65a66771a9e0819017ce76dee357b45dd556e2e4e3f6b41e718745119ef5f9a93554488bab6a90b81c3f63c64d9706e3f6ef3f1165ab16bf92df4bbdca0cbdbe84cc39beaefd771d3868b7b837fcb69dbff50bd00c0360c6fd5deba35e04d2a7800548dc9d0de4c6508b7d4409cd893bd786011576d60651794aa51912a8f06d6508fcc4f1a88306ab278de89cb414ee2ef121025090c2ce49b103816e8a2f0359935abfa688b8035f74a563e120108d02b8bbbbc200849fc65f5624ce86db41eec49328bc41676707b609d72f67b0161b98e704c833f21ee3f633b23658e48187671485a7b256fd2edd296dc74c4dbc976bf63111b0cd714a6e3960904201b7a087b25d018614a6bfee998ec6ad8b6cd0afd7161f5279841611934f6afbdcc33c14d5be22d8eaa8b510a5a6e87f6b04591e9a35785a28748f3ee5f1ac10568b1c4358d2aa83bba9fcc24e28cf8d5c1c13087afe3fc791a97b7faf55af020b06a82ab8d0130a316527c02223b77343358f46b645affe62c275bb5fe1f3b73887e95df5a887146628ac21abaa4c028e114a23d1362925054f9711d19df447f8a2cf7bfdeec20a13383911d64541fc5da75141fb5cd05afdd339de9604ee7bdfc4477f72d25b15576aeafc02a2ca56619f086ef5d3836d7bed7e0cd17b5b005d3a3065c849b15399b786b8cb0c5747501f46dd465b100b6fb3beb97b9fa5cee39fd116f600b3f19250e6f01e53fdb3ed03f5fb9509d8d69726c2ee91cf3d3d8211067b8cff1125ae16d8c8cd694e20fe8f1bfd77bbb68a0115bc513336c6467a50039356ec2810ccd6959cf1be42d67657589797589d1c0cbf7d051fdc3c77695743d5eb30d1c3a0bedfce99f42a5fd41030f90c83a4f354e5f938911840478d53c2d63e1666f8cf9562c73ef54ce18a9ede465147b96ff58a94cffe6ba9ee52d4e9cb29c86fb82e57e7b13052831bfb6fa66a65f4d8d523529a8f1a37b19d761820d872336ead31ed75c2df55941f59f721d860d1679bac920c51aab699dc71434140e2ae99bb9dde19bfb46e7b06a118b972282cee524040050f67703d0c19a1832336dd99aea8da4ef724a740cac6a76b7baf404612118fed6d85dd19d6e6116a7e7998a4c5b7579492ee5361e0b4eed9eea247e781617b8856f829be2e294fcf8326dff86e765282be24751eedf128af4d2cf61d14fb497f6f388a98bced9dac7c4348afc059b2fd79316d137f7cc0c82e49d4925046eba8967374d8dd2bacf9750ebdafd1c597328837b5ac8b38b8f5c3673922d199f6ef5e58d9a2326f52f8b924d70cba2d97efc5fd104ba2b0f429d0b2df825eb335b9cdc5a5050ad89900bb15a94e1a1c0c7c9595dd4e659b8358bd0ef05ced3f1ff9a0809f87668ba9128a4bbe233bcc475cdc242271055eb6ba63afa8d7538eeef4054c6baebff078f3ba838d08359bd6a284bfd1bc39c29d5a7046e64ec7880098bb4fc13d94430a052be4154a0a78db8dfb7c63f99af0f716f0ed072a43129edfd34fa4b672f5e5d0150a7095caa649254ce5749c8c4765ba4b334b68b4a8f57c43520d4c78907897b7514b356e1fc2eefe238f865dbc5a32210fcb738ebffd31472a2f3c7be11ff44b50bc965feef7ae5b46c28c7bae26058f362cafe2678d046e6c7a9bafbdeb32fb2545bae8d2c1f8d712c5a235d7b4817e73149846eeafb867fac7d2f7232f13e89820d524532866dcb7abbcc0b6ee4a0f87329c67138ab7fd9e44469325886679f80d45a546378ced4b6a73dc2fe9bc31e0d0bc80369a4dc4791536adc356c7ecb5b6e3cbba327dd51d98ab4b2cf1f068b2e2e489844fc236f6cbb92d51e17cf1a0ada6aea1b398c30b83421d63d64dca81ed6600352fd6dbba89ef13e319301c97038af29d3d47023fc3fc2627a5984f35b6f888840a164676743e7b5b960bf60949188a6ab87f2de18559577966e77e1c00a510ab592d07c2d61fb342fadacf35e4e85f6a7b709bdd08f4d381ff03d87b015c7ea32614d7850212d0a421276d70566dbd0f7a2b302010ba34c4aebf0f09d768da3230fc25597635bbf5b6c493184bbd554cd5b8c572466afb7737687c00bb53e1dc037915221dc951e08554c129e05e1caa4ffa6e96730d01d655c1450826a36249e30484167685147e4aa4ccacbe7b0b4377115aed76999de2b8c6e69c5aaa736ad44d3beebca8e9a7d86a5d2dd621f02600d570187a5b3033441e6a05de8f45a1643147394e210eb1e81263857bd4e3d693fa980dff57ad4b2359aa95531957810fa036767b2c8f18df0691b103b07ce8f5f0b186d5c9b88dbf3adc693c8dbb8b08f0f6bb9b5c04cbda41cf67cc9607bb24c54b5b5abc9dba0b207c2ce4d362ffa5e342f3239a31fe2306df7db48736530356be51b39f4762450d3a200a3f4d75121d3974ff70224dc5f56d1cb15e81f3e7c8802b13e72fc7ae542f7dff2deebe7b5fcbe995fd80bea1e690d1c648ad3a1e8f1b1c8f2fd17b22785cc728b96f66a23669c5cf2ed4ce1aa27988e8f5f2ecdbdd2c53b96535d275e2f68522dbc12f7aadfcb233d04bf9e31288c637e2a888951b0d8a08519e9af5a747375b2e52869e67add54ea39c2efbede3573d05673b3d7e244f039a31e9a0316f16344c0a2057f68f83d099ad058ac1f9b92d2c0ce3eba7d754ec9787f946a78a9f760c732cfd658fad15958554f385a84ed00b25e0bf9b4bdfc4bf319e3806deb6c06af02f10fce7c7f496dd1040e96aee5095ed7178d52e0de1b483780d34cabfdc7d264fcf2ffc3cebd66de2b01f0425598c1bb3d463487f2c811f922e736f91ad1c18da6ad574f94a4e260ae9df80953b3b8b562aba9d92ff252288f80f5d37ded88e01eff27ae9d8e7f1fc5dae6f20df0b5976b8f13a66f5b68d5aefcf9954ddc303482365b557e1271e4601374bae1476d45b1eb31139256db35f6ae0070d762e93f84f4213ceb9df258e1fdfa39bfda001ccc0788f6e9d52fc9654109c89cba42c836ec025ed2291b123ed620fe0e05b5da7db19664614978b8577c15d947712f192e8f00c5424194e1165bc80dbdf916983fa8e622665f45d4483505e4261453648cc129738e9dc131a62e3ceddf1246de1045c30a7af87ef219dd7ecab8dfa96a67217035b06ea041158876939a51750f1f006c5b4345cddb1a14fa3583746884322909a7ccdec1f847e90ff94adde29d565ce63c9942ba1808acef54f6d131d08a0a6785dc1897d809f840953d3075983ae63cfeb602860d77acbce357582970e76a65c0ef35abe8bcc7d9140b923d64052c6d8210b10887d187511a75558bf0b8e5315dc26411ca2b05c6be3b9274659622ad3faf577723056490d778a4de8007fdabc8f0668883b5afc85bccfc0436ccd6f3599247d98d0e5178851a2c6cffc44c08916b81b9084f1e08c47936fadfa676b94c65faf4579aa72f865fed950206a2b8c8e50b409bdcb9ba7bcf13b1619d737b771c45aea0d247406f48acba5e81c6ec68932087dc39de76475750c9422d0949a9070f0630b691a88abeba5e2aabc84eb718f820c9c88e9d2f96342433a1e040226e3b99535d96fdba0a2a2d990a93dcf8c9986b2269a622b34153c4abea320c10711d688741dad83166219aa234bb877d034073a3871a7c1cea5a4a6debf124ef47afe0b6c659d35cbf51648d611d98aa7cde6b01a9b193b73238eff4f95d38c258ae2bbec632127080e516402091fcbf363f4c6fa33d3b5018d49cf4d379a7b41166e55d403ddd5003e046c3318fd175ce963f0d6edb32a5d030aa46a2b47c08772278e21056175bc6c8e9793f1eeb40be6a6c4a908e7775e90f56ecd78ae8c24aa716bad660181a127cd78182ca99ffa0396c3adbf23e26d21fe7b1c6d72f51cc1a45668ac6ad55c5a92ee0fb2dc5a27f260297ffd48541884ede2a7b8e4ac4f8dd4d5f112a2210f9b71c990b26ea9105f0ff90397e7ab91bde0c71f6b14c9d3b9d422a0e0808ad63fa41c7be4ed79157a3cd2f0afe082461496130919d252aebb97b74a683701510a85b100b6c79eda14ebf2d06efd2d08651b889c5f04d92422f5b2e10ed4f3184bde5e7948edc33562df6898d3e597dd1d2f74e36ac9bcefc95e180d5ead4734af721985e959932b57acc5a1002950ed701f81f4d01bec20e20bb546dc9296f7b9453b69099784f22acebafdef6f3d409fdf88874b8ade2db69a2469896e5c616ae6e382d8ea44134b44ec77e4336d940dddad1126977cc39438a1f6424afa63ce75cc13467dcf4c6e45f81137cbfabfe6d6b6f493f2550ef78b9685e74faf70bed964d7a2eb17a68eec03cf8ae5e7b4e2ce85e0250071f18589e61333efd1b2f8a874fb08dcaf4077981193158ae1cccb2182f8b40217caa70b1990aed1074fc3ad21b0ae5314d287b714a8003ac4e708ba9052f47ce171c8daca6d9b3a2c2ef5b5962c3e1634115bfde7b88efa6966879b412cef53af9332cb8e5ac6b7f90b21c134f169187028cd0912b6feab66fa1759b7239c4857e9d91d4f5fb63bc6a0e3223d3a5bfd31891fe555a746b938465ea98f011f9add941c3312646057249222a7eb692379df2bbd622420f0d2dc306951cd12911f6a80609d319152aa29368ed4f9fe31b03580ec31508fa173fde9cdf50cf630438fa982e5ca31ee2ad78f80daff0b9cef8e44cdd5e96a9ce088c770d977f3509b85d926b9c1ac2e2177371729c49bc601c1eeff5a415aa0fa721b590991b2f9556ccb345e72a943707185a7809dea2aa9d8f5bd175ae835c22a185baee8910ee11359a72d941de95b6e47e7863da32a0ef95cbb6bfabcf15f4efebd8d94e6a8ed497caf224f8ccbba9b2f5a6e2e245d18da552ecf8dbfc9405278b77a5a3a0c560f22c4015a56c9632e9b36706484f23a4afc75d3608b2a761441e2c904f33ce6f589f8171112a74ddd1fe4d3c155cf61d5a2b4ddf917f7ca3cc7eacc77e0a499cef089b878a3496e50aa557b451bb27e58c257c4714b5b01e651f1f5167325797819fca33c73bbb1a89593dce3c802a0e3070cee9cdca3a1125ffffb00efb91a25949fe02c35c0bbb64c755404a574eaf00d9730c7eff1873ee3fcf78a0118f3cdeffe29d3635e2027d3a1fdfd0248afe3340e9910d724bb87f817956f7cbf88c93bad0989ebab4e6738594ffff5587456e8bc76cea910b1fe1a51dce4a53ddd7c52127386129540bcc3020546078b35c28e4d260e3ab74ae03faf47563348e7985a2cc6e0770dc976b55e41665a45920c5622e76a66f42f945cd2f43fab23889a65de5bfacf6e4fb42ba2b49c2e48b14f81bc7919ba71d01adc20ab0200f6f04f9473a9b799683ac973a5d79ea90444da4c343981c6fd93150b3ec9c96b5f43268fa748c0b167218ec6f7860731d722829a0a0d1e8670fd6d00405b79d406b55f4a4a46bcf4fbd7baa8e0ad332571ed86c1e476b8f53bf54f80eba59a4295fe6d021abad21eb6da0791bb1b7087d4f2df92d2940239596d31c0d16ea9811be39a648cc56553c223d0a012899ec92d3de07d38b20762f0cd02057a79a40bcb4bdba6a1d4e0d976ba3549d9c8a477e16d4181a4ea56b6297d165db9937b83ed240f29a8d45d9da0ac3174ed1321ff41aee215a881adeb144d884a54747b2f245a6b1eab7c2c1a07507d03acd0540bb479c30aa201bf027cbc83cf1f1d6fc3bf996e59141f0b2b0e8d6137e66e0507cfd23b5ac79a81b93a0174b9c5e26f6dfaa8be83f5a24afc6b94ec860b3fc426dd24648b8e5cdf10eee2837fab9f6481c60d84e9ef5cde9b404651ed115028556e7d49e7d4f010017676f6b576fd8db5a70f16db2bb43af925a3957a08ec5086aa03906a9dec6b5b016e929dc194a70edfdcb365b4edf77081cdbc8bd08748429ae8cea2738b36d6d98eed212acc6ac46c9609e47a0df2221dacd4d2918f889283a3caef2c2ecdf15eba514a4dbf997d98082d93e80e676900cd4d0ca8819eb7a8f323067147825d049bb2e88b529af946a1e6879e1e60d7ff9a72624c2de53877e15517768da836487fd7c498d8fb944869ad3356e2343127c2af4d713697547ff9f29fd5bcb048f0a16695647219f9b95d2e22f82add912fb46fa62e71ec70091048dc14f597f29c74c42a141219089067a65a7895f173ec6fed8c4b6d0509465d2db9b88da0670bd32bbd174f4c3a652f0faf547a3bb0fb463be7f806bdfd34a1184d71a7829ea19aa2b64dfff9f3f1892e8652ae29e7cd3ef5df0baf3c350e44aa6d46c027a71537f4b462aa0705e89102928708a51980f734f494d9416e90a4af884126b7b01cca750ae3581b3a70f5b5b8c069d39b01cd40bf621cc25fb82b00bc6ea50393ca18fb8942105f668483143160ea07da5fd53ea1faf8e7166206e88ae3882373df77703891a37e2c89e6f63f07cbfb358b47bc1539dffc21fdb3edd8036f67164f5e33ec17ea81cad0ffb1c92bb39a75c8a61ccbbb0128821cfb6ef2c9e767a5c34c0aff9eae91888b16b5e8088e4563223b3bab31aa58ee6b857a593ba9563b243109c6cbf7643299dc21259a8a464986e99ecf1d1f89bba31a44a2b72e99167c16754c58046734d6a977662ff719eef3ea0ebfe2537f404d940bbf83a61da0a29148a33f59ab8905af534b867a1a79f88f101fafe4aa0b6a0bbc30174f6e37429fb2e2d24edfc3605685cb473926ade3a3a5586e6a2d57d5f0bbcd239dbc67e7a0421ce39223d803630b466065c7f0c37f0f95f5568a9c8b7dabeac07bde40eac0afdf3697b0810c742749378745e3e0e8a8ef882e72e53365955fcbb8d809c91e950d6fb3285ce58dfad5499664d632a4f752689a7169fb2cfed465ad1932e64735c533c7d32a43cf77e26beea92574b38e89e45589f4893564c776472fe37a7357e9a580cf490d4c755aa0c947c01fa581a9368f62f0a662a8a335903c966b7efadd7acd508ea4ffe3c07051c88dc11d58a06cc3e8a475a01a7ecc04e8b8a30a31e3ef98a1812c3bf8d7d6b9cd2ecce9ea70a6a4806be50989d995826473fac768acac65b3a7afbeca0a40a3baad6d82df43d8d6dfa70024aa864328b09945254c4354086153e3dca5126bb652f1bd7a41ec4a9866b7c01ce6aa92ab1eee30eb20d8f43975f3648624415575e3fc86cac2443a2553d5af8c29b2c3d354bb8073bfc9fc8f801b4d99b8904866008e48ca6659cc89837f7239624de5df39141a9dc68479f9dc5d9fdd69d7197650a8864a0f6917420f127f47973668e8ddbe60926374f658d75e0c2653a74332862c0646a468570528063a7bdfec66a3b388d3dccb46ac350f7623192787976d78a32cafc6ff2581635171bf06fab5b88dc11858713ac8fa5e2cc7480ca7118f00d0e132f2241ea2c7cb5d5753e2f78d932985317549057c42845b7ed3bec97b90a4179ba1495d97a438805ff6fdf64edbe0d531c4a6e47a237cfd808bd21ff474b58d306cd258705f60097f608c34dbcea3f58d49150b7399c125c3dac85b2252ba307a8aa8d4233996aa2411dea33466db1b6ada67501de9abaea2254eeb3f21c7a65b14886246d1a509395c25eabee31eb58fca99723f31793b2282435719dbecc8cb67d4e8978bccc34b81fbec66125157242347b1343b2f6ba6c88da4c3fafbf92f0fc4a657373fead8cd7e92ac0601237849bfd0d1b48dc6c751d7536550673df60ebc028dd3e9ae7ced86138fba7b35e8629598f59215d7bcf5cc904186dc9c06d8f1b58c26f92773a2ac862ac33019d57900f690f5f35aa3d3960e051ee650ba94abed94f1324989d29816b99a650b45054317a57e3387e5d1868fe7beffe9f95f4bf2e9841de4d3bad63f1752949ee6e49f2740b601b4cdf4a5832794407d1c44f1f056083ced3394f9257a758874499588dc4fc4ef226778f8a2b09b4da30612111ad72ff951387b6f6759c64a603036740bfbeec36ea512bafcfd8e5473b458baff00cde18ead3c5c21875710014450a2030fa4b59c15c21f52d6925a0f54b17cbeb4ceb2cab8a258dd37d381d8928e91b793ee1388da4b39fe98385be8858ed</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> lives </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lives </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建指南</title>
      <link href="/2023/01/11/test-post/"/>
      <url>/2023/01/11/test-post/</url>
      
        <content type="html"><![CDATA[<p>Hello, everyone.</p><p>注明：本博客搭建借鉴于<a href="https://xkz0777.github.io/2021/07/19/build-website/">xkz</a>以及<a href="https://ysy-phoenix.github.io/2021/04052690.html">ysy</a>，还有最初的<a href="https://godweiyang.com/2018/04/13/hexo-blog/">godweiyang</a>的博客搭建指南，参考注意有先后顺序，避免一些过时的问题。</p><h2 id="引用图片"><a href="#引用图片" class="headerlink" title="引用图片"></a>引用图片</h2><p><strong>推荐使用图床上传</strong>，便于加快访问速度  </p><h3 id="本地资源导入"><a href="#本地资源导入" class="headerlink" title="本地资源导入"></a>本地资源导入</h3><img src="cover.jpg" alt="相对路径图片" style="zoom:33%;" /><p>添加方式：<br>在博客根目录下的_config.yml配置文件中，设置  </p><pre class="line-numbers language-none"><code class="language-none">post_asset_folder: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过命令hexo new post xxx，在source文件夹中生成xxx.md以及同名资源文件夹，之后如下形式引用：  </p><pre class="line-numbers language-none"><code class="language-none">&lt;img src&#x3D;&quot;cover.jpg&quot; alt&#x3D;&quot;相对路径图片&quot; style&#x3D;&quot;zoom:33%;&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="图床上传"><a href="#图床上传" class="headerlink" title="图床上传"></a>图床上传</h3><p><a href="https://imgse.com/i/pSKHRX9"><img src="https://s1.ax1x.com/2023/01/13/pSKHRX9.md.jpg" alt="图床照片"></a></p><p>添加方式：<br>搜索图床，选择合适的即可，可参考<a href="https://imgse.com/">这里</a></p><h2 id="添加友情链接"><a href="#添加友情链接" class="headerlink" title="添加友情链接"></a>添加友情链接</h2><p>在根目录sourse&#x2F;_data&#x2F;friends.json文件下设置，例如：  </p><pre class="line-numbers language-none"><code class="language-none">[  &#123;    &quot;avatar&quot;: &quot;https:&#x2F;&#x2F;ysy-phoenix.github.io&#x2F;medias&#x2F;avatar.jpg&quot;,    &quot;name&quot;: &quot;ysy&quot;,    &quot;introduction&quot;: &quot;ysy&quot;,    &quot;url&quot;: &quot;https:&#x2F;&#x2F;ysy-phoenix.github.io&#x2F;&quot;,    &quot;title&quot;: &quot;ysy的博客&quot;  &#125;,  &#123;    &quot;avatar&quot;: &quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;07&#x2F;12&#x2F;zWQo2VrLBstvDEU.jpg&quot;,    &quot;name&quot;: &quot;lly&quot;,    &quot;introduction&quot;: &quot;lly&quot;,    &quot;url&quot;: &quot;http:&#x2F;&#x2F;home.ustc.edu.cn&#x2F;~liuly0322&#x2F;blog&#x2F;&quot;,    &quot;title&quot;: &quot;lly的博客&quot;  &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="访问速度优化"><a href="#访问速度优化" class="headerlink" title="访问速度优化"></a>访问速度优化</h2><h3 id="部署至Coding"><a href="#部署至Coding" class="headerlink" title="部署至Coding"></a>部署至Coding</h3><p>该部分参考于<a href="https://zhuanlan.zhihu.com/p/466268978">这篇文章</a><br>-&gt;首先到<a href="https://coding.net/">官网</a>上进行注册<br>-&gt;创建项目(全功能DevOps项目)，项目名可以使github用户名<br>-&gt;创建代码仓库，仓库名用username.github.io，注意是公开仓库<br>-&gt;在仓库中将其地址复制至博客根目录下配置文件：</p><pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deploymentdeploy:- type: git  repository:     github: https:&#x2F;&#x2F;github.com&#x2F;HOUCQ4869&#x2F;HOUCQ4869.github.io    coding: https:&#x2F;&#x2F;e.coding.net&#x2F;houcq4869&#x2F;houcq4869&#x2F;houcq4869.github.io.git  branch: main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-&gt;导入外部仓库，即将github仓库导入至coding中<br>-&gt;修改分支，将默认分支改为main，注意可能要修改github默认分支为main，而不是master，可在\node_modules\hexo-deployer-git\lib\parse_config.js中查找master并改为main<br>-&gt;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d验证即可</p><p>网上许多方法都已过时，本篇作于2023年初，只具一定参考意义，可能并不会与时俱进，此外Coding Pages似乎也找不到，所以虽然实现了github，coding双线部署，但似乎并没有实现国内Coding，国外Github访问加速的目的，因此未完待续…… (感觉似乎快了些……)</p><h3 id="gulp4压缩静态文件"><a href="#gulp4压缩静态文件" class="headerlink" title="gulp4压缩静态文件"></a>gulp4压缩静态文件</h3><p>参考于<a href="https://blog.csdn.net/qq_43625917/article/details/104136304?app_version=5.7.2&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22104136304%22,%22source%22:%22unlogin%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">这篇博客</a>，如有问题可进一步查询<br><strong>1.安装gulp工具</strong>  </p><pre class="line-numbers language-none"><code class="language-none">npm install gulp -g&#x2F;npm install gulp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2.安装gulp插件</strong>  </p><pre class="line-numbers language-none"><code class="language-none">npm install gulp-minify-html gulp-minify-css gulp-uglify gulp-imagemin --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3.建立gulpfile.js文件</strong><br>在博客根目录下新建文件gulpfile.js  </p><pre class="line-numbers language-none"><code class="language-none">var gulp &#x3D; require(&#39;gulp&#39;);&#x2F;&#x2F;Plugins模块获取var minifycss &#x3D; require(&#39;gulp-minify-css&#39;);var uglify &#x3D; require(&#39;gulp-uglify&#39;);var minifyhtml &#x3D; require(&#39;gulp-minify-html&#39;);&#x2F;&#x2F; 压缩 public 目录 css文件gulp.task(&#39;minify-css&#39;, function () &#123;    return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.css&#39;)        .pipe(minifycss())        .pipe(gulp.dest(&#39;.&#x2F;public&#39;));&#125;);&#x2F;&#x2F; 压缩 public 目录 html文件gulp.task(&#39;minify-html&#39;, function () &#123;    return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.html&#39;)        .pipe(minifyhtml())        .pipe(gulp.dest(&#39;.&#x2F;public&#39;))&#125;);&#x2F;&#x2F; 压缩 public&#x2F;js 目录 js文件，忽略&#x2F;public&#x2F;lib&#x2F;blog-encrypt.jsgulp.task(&#39;minify-js&#39;, function () &#123;    &#x2F;&#x2F;纠错前：return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.js&#39;)    return gulp.src([&#39;.&#x2F;public&#x2F;**&#x2F;*.js&#39;, &#39;!.&#x2F;public&#x2F;lib&#x2F;blog-encrypt.js&#39;])        .pipe(uglify())        .pipe(gulp.dest(&#39;.&#x2F;public&#39;))&#125;);&#x2F;&#x2F; 压缩图片&#x2F;&#x2F;gulp.task(&#39;minify-images&#39;, function() &#123;&#x2F;&#x2F;    return gulp.src(&#39;.&#x2F;public&#x2F;images&#x2F;**&#x2F;*.*&#39;)&#x2F;&#x2F;        .pipe(imagemin(&#x2F;&#x2F;        [imagemin.gifsicle(&#123;&#39;optimizationLevel&#39;: 3&#125;),&#x2F;&#x2F;        imagemin.jpegtran(&#123;&#39;progressive&#39;: true&#125;),&#x2F;&#x2F;        imagemin.optipng(&#123;&#39;optimizationLevel&#39;: 7&#125;),&#x2F;&#x2F;        imagemin.svgo()],&#x2F;&#x2F;        &#123;&#39;verbose&#39;: true&#125;))&#x2F;&#x2F;        .pipe(gulp.dest(&#39;.&#x2F;public&#x2F;images&#39;))&#x2F;&#x2F;&#125;);&#x2F;&#x2F;因为我图片用的第三方图床存放的，所以就没压缩图片。(并且最后测试压缩图片时，发现有点权限问题，&#x2F;&#x2F; 分别执行css、heml、js的压缩任务gulp.task(&#39;default&#39;, gulp.parallel(&#39;minify-css&#39;, &#39;minify-html&#39;, &#39;minify-js&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意上面的public目录是否为你的真实目录，**代表0或多个子目录  </p><p><strong>4.部署执行</strong>  </p><pre class="line-numbers language-none"><code class="language-none">hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexio d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现提示未安装成功，再安装一次应该就可以<br>除此之外，可以在package.json文件里添加  </p><pre class="line-numbers language-none"><code class="language-none">&quot;scripts:&quot;&#123;    &quot;hexo&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d&quot;&#125;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样就可以直接执行  </p><pre class="line-numbers language-none"><code class="language-none">npm run hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用jsDeliver-Github实现加速"><a href="#使用jsDeliver-Github实现加速" class="headerlink" title="使用jsDeliver+Github实现加速"></a>使用jsDeliver+Github实现加速</h3><p>本文主要参考于<a href="https://zhuanlan.zhihu.com/p/346643522">这篇文章</a><br>大体思路为在github上新建仓库专门储存博客部分资源，通过jsDeliver引用资源<br><strong>1.新建仓库，并将需要cdn加速的资源上传到该仓库</strong>，如themes中的source文件夹</p><pre class="line-numbers language-none"><code class="language-none">git initgit remote add 名字 连接地址git remote -v &#x2F;&#x2F;测试git add .git status &#x2F;&#x2F;查看状态git commit -m &#39;inital&#39;git push -u 名字 分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于git指令操作不熟悉的可参考<a href="https://blog.csdn.net/qq_36667170/article/details/79085301">这篇文章</a>  </p><p><strong>2.点击右侧creat a new release发布版本</strong><br>自定义发布版，如新建tag1.0，下面title填写1.0  </p><p><strong>3.通过jsDeliver引用资源</strong>  </p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;你的用户名&#x2F;你的仓库名@发布的版本号&#x2F;文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若不使用版本号，默认为最新版本<br>可将hexo 中用到静态资源的地方换为cdn加速，如主题配置文件中：  </p><pre class="line-numbers language-none"><code class="language-none"># The used front-end library can be replaced with the corresponding CDN address as needed,# If the specific version is not specified below, you can use the latest version.# 使用到的前端库，可按需替换成对应的CDN地址，如果下面未指定具体的版本号，使用最新的版本即可.# 注：jsdelivr可以自动帮你生成.min版的js和css，所以你在设置js及css路径中可以直接写.min.xxxlibs:  css:    matery: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;css&#x2F;matery.css    mycss: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;css&#x2F;my.css    fontAwesome: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;awesome&#x2F;css&#x2F;all.css # V5.11.1    materialize: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;materialize&#x2F;materialize.min.css # 1.0.0    aos: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;aos&#x2F;aos.css    animate: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;animate&#x2F;animate.min.css # V3.5.1    lightgallery: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;lightGallery&#x2F;css&#x2F;lightgallery.min.css # V1.6.11    aplayer: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;aplayer&#x2F;APlayer.min.css    dplayer: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;dplayer&#x2F;DPlayer.min.css    gitalk: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;gitalk&#x2F;gitalk.css    jqcloud: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;jqcloud&#x2F;jqcloud.css    tocbot: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;tocbot&#x2F;tocbot.css    prism: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;prism&#x2F;prism.css  js:    matery: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;js&#x2F;matery.js    jquery: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;jquery&#x2F;jquery.min.js    materialize: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;materialize&#x2F;materialize.min.js # 1.0.0    masonry: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;masonry&#x2F;masonry.pkgd.min.js # v4.0.0    aos: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;aos&#x2F;aos.js    scrollProgress: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;scrollprogress&#x2F;scrollProgress.min.js    lightgallery: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;lightGallery&#x2F;js&#x2F;lightgallery-all.min.js # V1.6.11    clicklove: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;others&#x2F;clicklove.js    busuanzi: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;others&#x2F;busuanzi.pure.mini.js    aplayer: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;aplayer&#x2F;APlayer.min.js    dplayer: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;dplayer&#x2F;DPlayer.min.js    crypto: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;cryptojs&#x2F;crypto-js.min.js    echarts: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;echarts&#x2F;echarts.min.js    gitalk: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;gitalk&#x2F;gitalk.min.js    valine: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;valine&#x2F;Valine.min.js # 若想保持最新版，请替换为 https:&#x2F;&#x2F;unpkg.com&#x2F;valine&#x2F;dist&#x2F;Valine.min.js  默认为 &#x2F;libs&#x2F;valine&#x2F;Valine.min.js    minivaline: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;minivaline&#x2F;MiniValine.js    jqcloud: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;jqcloud&#x2F;jqcloud-1.0.4.min.js    tocbot: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;tocbot&#x2F;tocbot.min.js    canvas_nest: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;background&#x2F;canvas-nest.js    ribbon: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;background&#x2F;ribbon.min.js    ribbonRefresh: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;background&#x2F;ribbon-refresh.min.js    ribbon_dynamic: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;background&#x2F;ribbon-dynamic.js    instantpage: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;instantpage&#x2F;instantpage.js    snow: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;libs&#x2F;others&#x2F;snow.js# The post featured images that needs to be displayed when there is no image.# 无文章特色图片时需要显示的文章特色图片.featureImages:- https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;medias&#x2F;featureimages&#x2F;0.jpg- https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;medias&#x2F;featureimages&#x2F;1.jpg- https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;medias&#x2F;featureimages&#x2F;2.jpg- https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;HOUCQ4869&#x2F;mycdn&#x2F;source&#x2F;medias&#x2F;featureimages&#x2F;3.jpg……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.最后执行命令，over</strong></p><pre class="line-numbers language-none"><code class="language-none">npm run hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/11/hello-world/"/>
      <url>/2023/01/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
